#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import Status.ttypes
import Types.ttypes
import Exprs.ttypes
import Descriptors.ttypes
import PlanNodes.ttypes
import Planner.ttypes
import DataSinks.ttypes
import Data.ttypes
import RuntimeProfile.ttypes
import ImpalaService.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class ImpalaInternalServiceVersion:
  V1 = 0

  _VALUES_TO_NAMES = {
    0: "V1",
  }

  _NAMES_TO_VALUES = {
    "V1": 0,
  }


class TQueryOptions:
  """
  Attributes:
   - abort_on_error
   - max_errors
   - disable_codegen
   - batch_size
   - num_nodes
   - max_scan_range_length
   - num_scanner_threads
   - max_io_buffers
   - allow_unsupported_formats
   - default_order_by_limit
   - debug_action
   - mem_limit
   - abort_on_default_limit_exceeded
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'abort_on_error', None, False, ), # 1
    (2, TType.I32, 'max_errors', None, 0, ), # 2
    (3, TType.BOOL, 'disable_codegen', None, False, ), # 3
    (4, TType.I32, 'batch_size', None, 0, ), # 4
    (5, TType.I32, 'num_nodes', None, 0, ), # 5
    (6, TType.I64, 'max_scan_range_length', None, 0, ), # 6
    (7, TType.I32, 'num_scanner_threads', None, 0, ), # 7
    (8, TType.I32, 'max_io_buffers', None, 0, ), # 8
    (9, TType.BOOL, 'allow_unsupported_formats', None, False, ), # 9
    (10, TType.I64, 'default_order_by_limit', None, -1, ), # 10
    (11, TType.STRING, 'debug_action', None, "", ), # 11
    (12, TType.I64, 'mem_limit', None, 0, ), # 12
    (13, TType.BOOL, 'abort_on_default_limit_exceeded', None, False, ), # 13
  )

  def __init__(self, abort_on_error=thrift_spec[1][4], max_errors=thrift_spec[2][4], disable_codegen=thrift_spec[3][4], batch_size=thrift_spec[4][4], num_nodes=thrift_spec[5][4], max_scan_range_length=thrift_spec[6][4], num_scanner_threads=thrift_spec[7][4], max_io_buffers=thrift_spec[8][4], allow_unsupported_formats=thrift_spec[9][4], default_order_by_limit=thrift_spec[10][4], debug_action=thrift_spec[11][4], mem_limit=thrift_spec[12][4], abort_on_default_limit_exceeded=thrift_spec[13][4],):
    self.abort_on_error = abort_on_error
    self.max_errors = max_errors
    self.disable_codegen = disable_codegen
    self.batch_size = batch_size
    self.num_nodes = num_nodes
    self.max_scan_range_length = max_scan_range_length
    self.num_scanner_threads = num_scanner_threads
    self.max_io_buffers = max_io_buffers
    self.allow_unsupported_formats = allow_unsupported_formats
    self.default_order_by_limit = default_order_by_limit
    self.debug_action = debug_action
    self.mem_limit = mem_limit
    self.abort_on_default_limit_exceeded = abort_on_default_limit_exceeded

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.abort_on_error = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.max_errors = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.disable_codegen = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.batch_size = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.num_nodes = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.max_scan_range_length = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.num_scanner_threads = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.max_io_buffers = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.allow_unsupported_formats = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I64:
          self.default_order_by_limit = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.debug_action = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I64:
          self.mem_limit = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.BOOL:
          self.abort_on_default_limit_exceeded = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TQueryOptions')
    if self.abort_on_error is not None:
      oprot.writeFieldBegin('abort_on_error', TType.BOOL, 1)
      oprot.writeBool(self.abort_on_error)
      oprot.writeFieldEnd()
    if self.max_errors is not None:
      oprot.writeFieldBegin('max_errors', TType.I32, 2)
      oprot.writeI32(self.max_errors)
      oprot.writeFieldEnd()
    if self.disable_codegen is not None:
      oprot.writeFieldBegin('disable_codegen', TType.BOOL, 3)
      oprot.writeBool(self.disable_codegen)
      oprot.writeFieldEnd()
    if self.batch_size is not None:
      oprot.writeFieldBegin('batch_size', TType.I32, 4)
      oprot.writeI32(self.batch_size)
      oprot.writeFieldEnd()
    if self.num_nodes is not None:
      oprot.writeFieldBegin('num_nodes', TType.I32, 5)
      oprot.writeI32(self.num_nodes)
      oprot.writeFieldEnd()
    if self.max_scan_range_length is not None:
      oprot.writeFieldBegin('max_scan_range_length', TType.I64, 6)
      oprot.writeI64(self.max_scan_range_length)
      oprot.writeFieldEnd()
    if self.num_scanner_threads is not None:
      oprot.writeFieldBegin('num_scanner_threads', TType.I32, 7)
      oprot.writeI32(self.num_scanner_threads)
      oprot.writeFieldEnd()
    if self.max_io_buffers is not None:
      oprot.writeFieldBegin('max_io_buffers', TType.I32, 8)
      oprot.writeI32(self.max_io_buffers)
      oprot.writeFieldEnd()
    if self.allow_unsupported_formats is not None:
      oprot.writeFieldBegin('allow_unsupported_formats', TType.BOOL, 9)
      oprot.writeBool(self.allow_unsupported_formats)
      oprot.writeFieldEnd()
    if self.default_order_by_limit is not None:
      oprot.writeFieldBegin('default_order_by_limit', TType.I64, 10)
      oprot.writeI64(self.default_order_by_limit)
      oprot.writeFieldEnd()
    if self.debug_action is not None:
      oprot.writeFieldBegin('debug_action', TType.STRING, 11)
      oprot.writeString(self.debug_action)
      oprot.writeFieldEnd()
    if self.mem_limit is not None:
      oprot.writeFieldBegin('mem_limit', TType.I64, 12)
      oprot.writeI64(self.mem_limit)
      oprot.writeFieldEnd()
    if self.abort_on_default_limit_exceeded is not None:
      oprot.writeFieldBegin('abort_on_default_limit_exceeded', TType.BOOL, 13)
      oprot.writeBool(self.abort_on_default_limit_exceeded)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TScanRangeParams:
  """
  Attributes:
   - scan_range
   - volume_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'scan_range', (PlanNodes.ttypes.TScanRange, PlanNodes.ttypes.TScanRange.thrift_spec), None, ), # 1
    (2, TType.I32, 'volume_id', None, -1, ), # 2
  )

  def __init__(self, scan_range=None, volume_id=thrift_spec[2][4],):
    self.scan_range = scan_range
    self.volume_id = volume_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.scan_range = PlanNodes.ttypes.TScanRange()
          self.scan_range.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.volume_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TScanRangeParams')
    if self.scan_range is not None:
      oprot.writeFieldBegin('scan_range', TType.STRUCT, 1)
      self.scan_range.write(oprot)
      oprot.writeFieldEnd()
    if self.volume_id is not None:
      oprot.writeFieldBegin('volume_id', TType.I32, 2)
      oprot.writeI32(self.volume_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.scan_range is None:
      raise TProtocol.TProtocolException(message='Required field scan_range is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPlanFragmentDestination:
  """
  Attributes:
   - fragment_instance_id
   - server
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'fragment_instance_id', (Types.ttypes.TUniqueId, Types.ttypes.TUniqueId.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'server', (Types.ttypes.TNetworkAddress, Types.ttypes.TNetworkAddress.thrift_spec), None, ), # 2
  )

  def __init__(self, fragment_instance_id=None, server=None,):
    self.fragment_instance_id = fragment_instance_id
    self.server = server

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.fragment_instance_id = Types.ttypes.TUniqueId()
          self.fragment_instance_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.server = Types.ttypes.TNetworkAddress()
          self.server.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPlanFragmentDestination')
    if self.fragment_instance_id is not None:
      oprot.writeFieldBegin('fragment_instance_id', TType.STRUCT, 1)
      self.fragment_instance_id.write(oprot)
      oprot.writeFieldEnd()
    if self.server is not None:
      oprot.writeFieldBegin('server', TType.STRUCT, 2)
      self.server.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.fragment_instance_id is None:
      raise TProtocol.TProtocolException(message='Required field fragment_instance_id is unset!')
    if self.server is None:
      raise TProtocol.TProtocolException(message='Required field server is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPlanFragmentExecParams:
  """
  Attributes:
   - query_id
   - fragment_instance_id
   - per_node_scan_ranges
   - per_exch_num_senders
   - destinations
   - debug_node_id
   - debug_phase
   - debug_action
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'query_id', (Types.ttypes.TUniqueId, Types.ttypes.TUniqueId.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'fragment_instance_id', (Types.ttypes.TUniqueId, Types.ttypes.TUniqueId.thrift_spec), None, ), # 2
    (3, TType.MAP, 'per_node_scan_ranges', (TType.I32,None,TType.LIST,(TType.STRUCT,(TScanRangeParams, TScanRangeParams.thrift_spec))), None, ), # 3
    (4, TType.MAP, 'per_exch_num_senders', (TType.I32,None,TType.I32,None), None, ), # 4
    (5, TType.LIST, 'destinations', (TType.STRUCT,(TPlanFragmentDestination, TPlanFragmentDestination.thrift_spec)), None, ), # 5
    (6, TType.I32, 'debug_node_id', None, None, ), # 6
    (7, TType.I32, 'debug_phase', None, None, ), # 7
    (8, TType.I32, 'debug_action', None, None, ), # 8
  )

  def __init__(self, query_id=None, fragment_instance_id=None, per_node_scan_ranges=None, per_exch_num_senders=None, destinations=None, debug_node_id=None, debug_phase=None, debug_action=None,):
    self.query_id = query_id
    self.fragment_instance_id = fragment_instance_id
    self.per_node_scan_ranges = per_node_scan_ranges
    self.per_exch_num_senders = per_exch_num_senders
    self.destinations = destinations
    self.debug_node_id = debug_node_id
    self.debug_phase = debug_phase
    self.debug_action = debug_action

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.query_id = Types.ttypes.TUniqueId()
          self.query_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.fragment_instance_id = Types.ttypes.TUniqueId()
          self.fragment_instance_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.per_node_scan_ranges = {}
          (_ktype1, _vtype2, _size0 ) = iprot.readMapBegin() 
          for _i4 in xrange(_size0):
            _key5 = iprot.readI32();
            _val6 = []
            (_etype10, _size7) = iprot.readListBegin()
            for _i11 in xrange(_size7):
              _elem12 = TScanRangeParams()
              _elem12.read(iprot)
              _val6.append(_elem12)
            iprot.readListEnd()
            self.per_node_scan_ranges[_key5] = _val6
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.per_exch_num_senders = {}
          (_ktype14, _vtype15, _size13 ) = iprot.readMapBegin() 
          for _i17 in xrange(_size13):
            _key18 = iprot.readI32();
            _val19 = iprot.readI32();
            self.per_exch_num_senders[_key18] = _val19
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.destinations = []
          (_etype23, _size20) = iprot.readListBegin()
          for _i24 in xrange(_size20):
            _elem25 = TPlanFragmentDestination()
            _elem25.read(iprot)
            self.destinations.append(_elem25)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.debug_node_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.debug_phase = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.debug_action = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPlanFragmentExecParams')
    if self.query_id is not None:
      oprot.writeFieldBegin('query_id', TType.STRUCT, 1)
      self.query_id.write(oprot)
      oprot.writeFieldEnd()
    if self.fragment_instance_id is not None:
      oprot.writeFieldBegin('fragment_instance_id', TType.STRUCT, 2)
      self.fragment_instance_id.write(oprot)
      oprot.writeFieldEnd()
    if self.per_node_scan_ranges is not None:
      oprot.writeFieldBegin('per_node_scan_ranges', TType.MAP, 3)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.per_node_scan_ranges))
      for kiter26,viter27 in self.per_node_scan_ranges.items():
        oprot.writeI32(kiter26)
        oprot.writeListBegin(TType.STRUCT, len(viter27))
        for iter28 in viter27:
          iter28.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.per_exch_num_senders is not None:
      oprot.writeFieldBegin('per_exch_num_senders', TType.MAP, 4)
      oprot.writeMapBegin(TType.I32, TType.I32, len(self.per_exch_num_senders))
      for kiter29,viter30 in self.per_exch_num_senders.items():
        oprot.writeI32(kiter29)
        oprot.writeI32(viter30)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.destinations is not None:
      oprot.writeFieldBegin('destinations', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.destinations))
      for iter31 in self.destinations:
        iter31.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.debug_node_id is not None:
      oprot.writeFieldBegin('debug_node_id', TType.I32, 6)
      oprot.writeI32(self.debug_node_id)
      oprot.writeFieldEnd()
    if self.debug_phase is not None:
      oprot.writeFieldBegin('debug_phase', TType.I32, 7)
      oprot.writeI32(self.debug_phase)
      oprot.writeFieldEnd()
    if self.debug_action is not None:
      oprot.writeFieldBegin('debug_action', TType.I32, 8)
      oprot.writeI32(self.debug_action)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.query_id is None:
      raise TProtocol.TProtocolException(message='Required field query_id is unset!')
    if self.fragment_instance_id is None:
      raise TProtocol.TProtocolException(message='Required field fragment_instance_id is unset!')
    if self.per_node_scan_ranges is None:
      raise TProtocol.TProtocolException(message='Required field per_node_scan_ranges is unset!')
    if self.per_exch_num_senders is None:
      raise TProtocol.TProtocolException(message='Required field per_exch_num_senders is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TQueryGlobals:
  """
  Attributes:
   - now_string
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'now_string', None, None, ), # 1
  )

  def __init__(self, now_string=None,):
    self.now_string = now_string

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.now_string = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TQueryGlobals')
    if self.now_string is not None:
      oprot.writeFieldBegin('now_string', TType.STRING, 1)
      oprot.writeString(self.now_string)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.now_string is None:
      raise TProtocol.TProtocolException(message='Required field now_string is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TExecPlanFragmentParams:
  """
  Attributes:
   - protocol_version
   - fragment
   - desc_tbl
   - params
   - coord
   - backend_num
   - query_globals
   - query_options
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'protocol_version', None, None, ), # 1
    (2, TType.STRUCT, 'fragment', (Planner.ttypes.TPlanFragment, Planner.ttypes.TPlanFragment.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'desc_tbl', (Descriptors.ttypes.TDescriptorTable, Descriptors.ttypes.TDescriptorTable.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'params', (TPlanFragmentExecParams, TPlanFragmentExecParams.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'coord', (Types.ttypes.TNetworkAddress, Types.ttypes.TNetworkAddress.thrift_spec), None, ), # 5
    (6, TType.I32, 'backend_num', None, None, ), # 6
    (7, TType.STRUCT, 'query_globals', (TQueryGlobals, TQueryGlobals.thrift_spec), None, ), # 7
    (8, TType.STRUCT, 'query_options', (TQueryOptions, TQueryOptions.thrift_spec), None, ), # 8
  )

  def __init__(self, protocol_version=None, fragment=None, desc_tbl=None, params=None, coord=None, backend_num=None, query_globals=None, query_options=None,):
    self.protocol_version = protocol_version
    self.fragment = fragment
    self.desc_tbl = desc_tbl
    self.params = params
    self.coord = coord
    self.backend_num = backend_num
    self.query_globals = query_globals
    self.query_options = query_options

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.protocol_version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.fragment = Planner.ttypes.TPlanFragment()
          self.fragment.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.desc_tbl = Descriptors.ttypes.TDescriptorTable()
          self.desc_tbl.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.params = TPlanFragmentExecParams()
          self.params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.coord = Types.ttypes.TNetworkAddress()
          self.coord.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.backend_num = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.query_globals = TQueryGlobals()
          self.query_globals.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.query_options = TQueryOptions()
          self.query_options.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TExecPlanFragmentParams')
    if self.protocol_version is not None:
      oprot.writeFieldBegin('protocol_version', TType.I32, 1)
      oprot.writeI32(self.protocol_version)
      oprot.writeFieldEnd()
    if self.fragment is not None:
      oprot.writeFieldBegin('fragment', TType.STRUCT, 2)
      self.fragment.write(oprot)
      oprot.writeFieldEnd()
    if self.desc_tbl is not None:
      oprot.writeFieldBegin('desc_tbl', TType.STRUCT, 3)
      self.desc_tbl.write(oprot)
      oprot.writeFieldEnd()
    if self.params is not None:
      oprot.writeFieldBegin('params', TType.STRUCT, 4)
      self.params.write(oprot)
      oprot.writeFieldEnd()
    if self.coord is not None:
      oprot.writeFieldBegin('coord', TType.STRUCT, 5)
      self.coord.write(oprot)
      oprot.writeFieldEnd()
    if self.backend_num is not None:
      oprot.writeFieldBegin('backend_num', TType.I32, 6)
      oprot.writeI32(self.backend_num)
      oprot.writeFieldEnd()
    if self.query_globals is not None:
      oprot.writeFieldBegin('query_globals', TType.STRUCT, 7)
      self.query_globals.write(oprot)
      oprot.writeFieldEnd()
    if self.query_options is not None:
      oprot.writeFieldBegin('query_options', TType.STRUCT, 8)
      self.query_options.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.protocol_version is None:
      raise TProtocol.TProtocolException(message='Required field protocol_version is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TExecPlanFragmentResult:
  """
  Attributes:
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (Status.ttypes.TStatus, Status.ttypes.TStatus.thrift_spec), None, ), # 1
  )

  def __init__(self, status=None,):
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = Status.ttypes.TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TExecPlanFragmentResult')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TInsertExecStatus:
  """
  Attributes:
   - num_appended_rows
   - files_to_move
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'num_appended_rows', (TType.STRING,None,TType.I64,None), None, ), # 1
    (2, TType.MAP, 'files_to_move', (TType.STRING,None,TType.STRING,None), None, ), # 2
  )

  def __init__(self, num_appended_rows=None, files_to_move=None,):
    self.num_appended_rows = num_appended_rows
    self.files_to_move = files_to_move

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.num_appended_rows = {}
          (_ktype33, _vtype34, _size32 ) = iprot.readMapBegin() 
          for _i36 in xrange(_size32):
            _key37 = iprot.readString();
            _val38 = iprot.readI64();
            self.num_appended_rows[_key37] = _val38
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.files_to_move = {}
          (_ktype40, _vtype41, _size39 ) = iprot.readMapBegin() 
          for _i43 in xrange(_size39):
            _key44 = iprot.readString();
            _val45 = iprot.readString();
            self.files_to_move[_key44] = _val45
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TInsertExecStatus')
    if self.num_appended_rows is not None:
      oprot.writeFieldBegin('num_appended_rows', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.I64, len(self.num_appended_rows))
      for kiter46,viter47 in self.num_appended_rows.items():
        oprot.writeString(kiter46)
        oprot.writeI64(viter47)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.files_to_move is not None:
      oprot.writeFieldBegin('files_to_move', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.files_to_move))
      for kiter48,viter49 in self.files_to_move.items():
        oprot.writeString(kiter48)
        oprot.writeString(viter49)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.files_to_move is None:
      raise TProtocol.TProtocolException(message='Required field files_to_move is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TReportExecStatusParams:
  """
  Attributes:
   - protocol_version
   - query_id
   - backend_num
   - fragment_instance_id
   - status
   - done
   - profile
   - insert_exec_status
   - error_log
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'protocol_version', None, None, ), # 1
    (2, TType.STRUCT, 'query_id', (Types.ttypes.TUniqueId, Types.ttypes.TUniqueId.thrift_spec), None, ), # 2
    (3, TType.I32, 'backend_num', None, None, ), # 3
    (4, TType.STRUCT, 'fragment_instance_id', (Types.ttypes.TUniqueId, Types.ttypes.TUniqueId.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'status', (Status.ttypes.TStatus, Status.ttypes.TStatus.thrift_spec), None, ), # 5
    (6, TType.BOOL, 'done', None, None, ), # 6
    (7, TType.STRUCT, 'profile', (RuntimeProfile.ttypes.TRuntimeProfileTree, RuntimeProfile.ttypes.TRuntimeProfileTree.thrift_spec), None, ), # 7
    (8, TType.STRUCT, 'insert_exec_status', (TInsertExecStatus, TInsertExecStatus.thrift_spec), None, ), # 8
    (9, TType.LIST, 'error_log', (TType.STRING,None), None, ), # 9
  )

  def __init__(self, protocol_version=None, query_id=None, backend_num=None, fragment_instance_id=None, status=None, done=None, profile=None, insert_exec_status=None, error_log=None,):
    self.protocol_version = protocol_version
    self.query_id = query_id
    self.backend_num = backend_num
    self.fragment_instance_id = fragment_instance_id
    self.status = status
    self.done = done
    self.profile = profile
    self.insert_exec_status = insert_exec_status
    self.error_log = error_log

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.protocol_version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.query_id = Types.ttypes.TUniqueId()
          self.query_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.backend_num = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.fragment_instance_id = Types.ttypes.TUniqueId()
          self.fragment_instance_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.status = Status.ttypes.TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.done = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.profile = RuntimeProfile.ttypes.TRuntimeProfileTree()
          self.profile.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.insert_exec_status = TInsertExecStatus()
          self.insert_exec_status.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.error_log = []
          (_etype53, _size50) = iprot.readListBegin()
          for _i54 in xrange(_size50):
            _elem55 = iprot.readString();
            self.error_log.append(_elem55)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TReportExecStatusParams')
    if self.protocol_version is not None:
      oprot.writeFieldBegin('protocol_version', TType.I32, 1)
      oprot.writeI32(self.protocol_version)
      oprot.writeFieldEnd()
    if self.query_id is not None:
      oprot.writeFieldBegin('query_id', TType.STRUCT, 2)
      self.query_id.write(oprot)
      oprot.writeFieldEnd()
    if self.backend_num is not None:
      oprot.writeFieldBegin('backend_num', TType.I32, 3)
      oprot.writeI32(self.backend_num)
      oprot.writeFieldEnd()
    if self.fragment_instance_id is not None:
      oprot.writeFieldBegin('fragment_instance_id', TType.STRUCT, 4)
      self.fragment_instance_id.write(oprot)
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 5)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    if self.done is not None:
      oprot.writeFieldBegin('done', TType.BOOL, 6)
      oprot.writeBool(self.done)
      oprot.writeFieldEnd()
    if self.profile is not None:
      oprot.writeFieldBegin('profile', TType.STRUCT, 7)
      self.profile.write(oprot)
      oprot.writeFieldEnd()
    if self.insert_exec_status is not None:
      oprot.writeFieldBegin('insert_exec_status', TType.STRUCT, 8)
      self.insert_exec_status.write(oprot)
      oprot.writeFieldEnd()
    if self.error_log is not None:
      oprot.writeFieldBegin('error_log', TType.LIST, 9)
      oprot.writeListBegin(TType.STRING, len(self.error_log))
      for iter56 in self.error_log:
        oprot.writeString(iter56)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.protocol_version is None:
      raise TProtocol.TProtocolException(message='Required field protocol_version is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TReportExecStatusResult:
  """
  Attributes:
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (Status.ttypes.TStatus, Status.ttypes.TStatus.thrift_spec), None, ), # 1
  )

  def __init__(self, status=None,):
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = Status.ttypes.TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TReportExecStatusResult')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCancelPlanFragmentParams:
  """
  Attributes:
   - protocol_version
   - fragment_instance_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'protocol_version', None, None, ), # 1
    (2, TType.STRUCT, 'fragment_instance_id', (Types.ttypes.TUniqueId, Types.ttypes.TUniqueId.thrift_spec), None, ), # 2
  )

  def __init__(self, protocol_version=None, fragment_instance_id=None,):
    self.protocol_version = protocol_version
    self.fragment_instance_id = fragment_instance_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.protocol_version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.fragment_instance_id = Types.ttypes.TUniqueId()
          self.fragment_instance_id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCancelPlanFragmentParams')
    if self.protocol_version is not None:
      oprot.writeFieldBegin('protocol_version', TType.I32, 1)
      oprot.writeI32(self.protocol_version)
      oprot.writeFieldEnd()
    if self.fragment_instance_id is not None:
      oprot.writeFieldBegin('fragment_instance_id', TType.STRUCT, 2)
      self.fragment_instance_id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.protocol_version is None:
      raise TProtocol.TProtocolException(message='Required field protocol_version is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCancelPlanFragmentResult:
  """
  Attributes:
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (Status.ttypes.TStatus, Status.ttypes.TStatus.thrift_spec), None, ), # 1
  )

  def __init__(self, status=None,):
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = Status.ttypes.TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCancelPlanFragmentResult')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TTransmitDataParams:
  """
  Attributes:
   - protocol_version
   - dest_fragment_instance_id
   - dest_node_id
   - row_batch
   - eos
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'protocol_version', None, None, ), # 1
    (2, TType.STRUCT, 'dest_fragment_instance_id', (Types.ttypes.TUniqueId, Types.ttypes.TUniqueId.thrift_spec), None, ), # 2
    None, # 3
    (4, TType.I32, 'dest_node_id', None, None, ), # 4
    (5, TType.STRUCT, 'row_batch', (Data.ttypes.TRowBatch, Data.ttypes.TRowBatch.thrift_spec), None, ), # 5
    (6, TType.BOOL, 'eos', None, None, ), # 6
  )

  def __init__(self, protocol_version=None, dest_fragment_instance_id=None, dest_node_id=None, row_batch=None, eos=None,):
    self.protocol_version = protocol_version
    self.dest_fragment_instance_id = dest_fragment_instance_id
    self.dest_node_id = dest_node_id
    self.row_batch = row_batch
    self.eos = eos

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.protocol_version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dest_fragment_instance_id = Types.ttypes.TUniqueId()
          self.dest_fragment_instance_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.dest_node_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.row_batch = Data.ttypes.TRowBatch()
          self.row_batch.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.eos = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TTransmitDataParams')
    if self.protocol_version is not None:
      oprot.writeFieldBegin('protocol_version', TType.I32, 1)
      oprot.writeI32(self.protocol_version)
      oprot.writeFieldEnd()
    if self.dest_fragment_instance_id is not None:
      oprot.writeFieldBegin('dest_fragment_instance_id', TType.STRUCT, 2)
      self.dest_fragment_instance_id.write(oprot)
      oprot.writeFieldEnd()
    if self.dest_node_id is not None:
      oprot.writeFieldBegin('dest_node_id', TType.I32, 4)
      oprot.writeI32(self.dest_node_id)
      oprot.writeFieldEnd()
    if self.row_batch is not None:
      oprot.writeFieldBegin('row_batch', TType.STRUCT, 5)
      self.row_batch.write(oprot)
      oprot.writeFieldEnd()
    if self.eos is not None:
      oprot.writeFieldBegin('eos', TType.BOOL, 6)
      oprot.writeBool(self.eos)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.protocol_version is None:
      raise TProtocol.TProtocolException(message='Required field protocol_version is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TTransmitDataResult:
  """
  Attributes:
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'status', (Status.ttypes.TStatus, Status.ttypes.TStatus.thrift_spec), None, ), # 1
  )

  def __init__(self, status=None,):
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.status = Status.ttypes.TStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TTransmitDataResult')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 1)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
