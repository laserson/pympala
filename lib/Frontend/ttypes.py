#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import Types.ttypes
import ImpalaInternalService.ttypes
import PlanNodes.ttypes
import Planner.ttypes
import Descriptors.ttypes
import Data.ttypes
import cli_service.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class TFileFormat:
  PARQUETFILE = 0
  RCFILE = 1
  SEQUENCEFILE = 2
  TEXTFILE = 3

  _VALUES_TO_NAMES = {
    0: "PARQUETFILE",
    1: "RCFILE",
    2: "SEQUENCEFILE",
    3: "TEXTFILE",
  }

  _NAMES_TO_VALUES = {
    "PARQUETFILE": 0,
    "RCFILE": 1,
    "SEQUENCEFILE": 2,
    "TEXTFILE": 3,
  }

class TAlterTableType:
  ADD_REPLACE_COLUMNS = 0
  ADD_PARTITION = 1
  CHANGE_COLUMN = 2
  DROP_COLUMN = 3
  DROP_PARTITION = 4
  RENAME_TABLE = 5
  SET_FILE_FORMAT = 6
  SET_LOCATION = 7

  _VALUES_TO_NAMES = {
    0: "ADD_REPLACE_COLUMNS",
    1: "ADD_PARTITION",
    2: "CHANGE_COLUMN",
    3: "DROP_COLUMN",
    4: "DROP_PARTITION",
    5: "RENAME_TABLE",
    6: "SET_FILE_FORMAT",
    7: "SET_LOCATION",
  }

  _NAMES_TO_VALUES = {
    "ADD_REPLACE_COLUMNS": 0,
    "ADD_PARTITION": 1,
    "CHANGE_COLUMN": 2,
    "DROP_COLUMN": 3,
    "DROP_PARTITION": 4,
    "RENAME_TABLE": 5,
    "SET_FILE_FORMAT": 6,
    "SET_LOCATION": 7,
  }

class TDdlType:
  SHOW_TABLES = 0
  SHOW_DBS = 1
  USE = 2
  DESCRIBE = 3
  ALTER_TABLE = 4
  CREATE_DATABASE = 5
  CREATE_TABLE = 6
  CREATE_TABLE_LIKE = 7
  DROP_DATABASE = 8
  DROP_TABLE = 9

  _VALUES_TO_NAMES = {
    0: "SHOW_TABLES",
    1: "SHOW_DBS",
    2: "USE",
    3: "DESCRIBE",
    4: "ALTER_TABLE",
    5: "CREATE_DATABASE",
    6: "CREATE_TABLE",
    7: "CREATE_TABLE_LIKE",
    8: "DROP_DATABASE",
    9: "DROP_TABLE",
  }

  _NAMES_TO_VALUES = {
    "SHOW_TABLES": 0,
    "SHOW_DBS": 1,
    "USE": 2,
    "DESCRIBE": 3,
    "ALTER_TABLE": 4,
    "CREATE_DATABASE": 5,
    "CREATE_TABLE": 6,
    "CREATE_TABLE_LIKE": 7,
    "DROP_DATABASE": 8,
    "DROP_TABLE": 9,
  }

class TMetadataOpcode:
  GET_TYPE_INFO = 0
  GET_CATALOGS = 1
  GET_SCHEMAS = 2
  GET_TABLES = 3
  GET_TABLE_TYPES = 4
  GET_COLUMNS = 5
  GET_FUNCTIONS = 6

  _VALUES_TO_NAMES = {
    0: "GET_TYPE_INFO",
    1: "GET_CATALOGS",
    2: "GET_SCHEMAS",
    3: "GET_TABLES",
    4: "GET_TABLE_TYPES",
    5: "GET_COLUMNS",
    6: "GET_FUNCTIONS",
  }

  _NAMES_TO_VALUES = {
    "GET_TYPE_INFO": 0,
    "GET_CATALOGS": 1,
    "GET_SCHEMAS": 2,
    "GET_TABLES": 3,
    "GET_TABLE_TYPES": 4,
    "GET_COLUMNS": 5,
    "GET_FUNCTIONS": 6,
  }


class TGetTablesParams:
  """
  Attributes:
   - db
   - pattern
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db', None, None, ), # 1
    (2, TType.STRING, 'pattern', None, None, ), # 2
  )

  def __init__(self, db=None, pattern=None,):
    self.db = db
    self.pattern = pattern

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.pattern = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetTablesParams')
    if self.db is not None:
      oprot.writeFieldBegin('db', TType.STRING, 1)
      oprot.writeString(self.db)
      oprot.writeFieldEnd()
    if self.pattern is not None:
      oprot.writeFieldBegin('pattern', TType.STRING, 2)
      oprot.writeString(self.pattern)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetTablesResult:
  """
  Attributes:
   - tables
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'tables', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, tables=None,):
    self.tables = tables

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.tables = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readString();
            self.tables.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetTablesResult')
    if self.tables is not None:
      oprot.writeFieldBegin('tables', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.tables))
      for iter6 in self.tables:
        oprot.writeString(iter6)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetDbsParams:
  """
  Attributes:
   - pattern
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'pattern', None, None, ), # 1
  )

  def __init__(self, pattern=None,):
    self.pattern = pattern

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.pattern = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetDbsParams')
    if self.pattern is not None:
      oprot.writeFieldBegin('pattern', TType.STRING, 1)
      oprot.writeString(self.pattern)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGetDbsResult:
  """
  Attributes:
   - dbs
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'dbs', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, dbs=None,):
    self.dbs = dbs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.dbs = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readString();
            self.dbs.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGetDbsResult')
    if self.dbs is not None:
      oprot.writeFieldBegin('dbs', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.dbs))
      for iter13 in self.dbs:
        oprot.writeString(iter13)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TColumnDesc:
  """
  Attributes:
   - columnName
   - columnType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'columnName', None, None, ), # 1
    (2, TType.I32, 'columnType', None, None, ), # 2
  )

  def __init__(self, columnName=None, columnType=None,):
    self.columnName = columnName
    self.columnType = columnType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.columnName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.columnType = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TColumnDesc')
    if self.columnName is not None:
      oprot.writeFieldBegin('columnName', TType.STRING, 1)
      oprot.writeString(self.columnName)
      oprot.writeFieldEnd()
    if self.columnType is not None:
      oprot.writeFieldBegin('columnType', TType.I32, 2)
      oprot.writeI32(self.columnType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.columnName is None:
      raise TProtocol.TProtocolException(message='Required field columnName is unset!')
    if self.columnType is None:
      raise TProtocol.TProtocolException(message='Required field columnType is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TColumnDef:
  """
  Attributes:
   - columnDesc
   - comment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'columnDesc', (TColumnDesc, TColumnDesc.thrift_spec), None, ), # 1
    (2, TType.STRING, 'comment', None, None, ), # 2
  )

  def __init__(self, columnDesc=None, comment=None,):
    self.columnDesc = columnDesc
    self.comment = comment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.columnDesc = TColumnDesc()
          self.columnDesc.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.comment = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TColumnDef')
    if self.columnDesc is not None:
      oprot.writeFieldBegin('columnDesc', TType.STRUCT, 1)
      self.columnDesc.write(oprot)
      oprot.writeFieldEnd()
    if self.comment is not None:
      oprot.writeFieldBegin('comment', TType.STRING, 2)
      oprot.writeString(self.comment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.columnDesc is None:
      raise TProtocol.TProtocolException(message='Required field columnDesc is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDescribeTableParams:
  """
  Attributes:
   - db
   - table_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
  )

  def __init__(self, db=None, table_name=None,):
    self.db = db
    self.table_name = table_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDescribeTableParams')
    if self.db is not None:
      oprot.writeFieldBegin('db', TType.STRING, 1)
      oprot.writeString(self.db)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDescribeTableResult:
  """
  Attributes:
   - columns
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'columns', (TType.STRUCT,(TColumnDef, TColumnDef.thrift_spec)), None, ), # 1
  )

  def __init__(self, columns=None,):
    self.columns = columns

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.columns = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = TColumnDef()
            _elem19.read(iprot)
            self.columns.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDescribeTableResult')
    if self.columns is not None:
      oprot.writeFieldBegin('columns', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.columns))
      for iter20 in self.columns:
        iter20.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.columns is None:
      raise TProtocol.TProtocolException(message='Required field columns is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCreateDbParams:
  """
  Attributes:
   - db
   - comment
   - location
   - if_not_exists
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db', None, None, ), # 1
    (2, TType.STRING, 'comment', None, None, ), # 2
    (3, TType.STRING, 'location', None, None, ), # 3
    (4, TType.BOOL, 'if_not_exists', None, None, ), # 4
  )

  def __init__(self, db=None, comment=None, location=None, if_not_exists=None,):
    self.db = db
    self.comment = comment
    self.location = location
    self.if_not_exists = if_not_exists

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.comment = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.location = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCreateDbParams')
    if self.db is not None:
      oprot.writeFieldBegin('db', TType.STRING, 1)
      oprot.writeString(self.db)
      oprot.writeFieldEnd()
    if self.comment is not None:
      oprot.writeFieldBegin('comment', TType.STRING, 2)
      oprot.writeString(self.comment)
      oprot.writeFieldEnd()
    if self.location is not None:
      oprot.writeFieldBegin('location', TType.STRING, 3)
      oprot.writeString(self.location)
      oprot.writeFieldEnd()
    if self.if_not_exists is not None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 4)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.db is None:
      raise TProtocol.TProtocolException(message='Required field db is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TTableName:
  """
  Attributes:
   - db_name
   - table_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
  )

  def __init__(self, db_name=None, table_name=None,):
    self.db_name = db_name
    self.table_name = table_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TTableName')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.db_name is None:
      raise TProtocol.TProtocolException(message='Required field db_name is unset!')
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TTableRowFormat:
  """
  Attributes:
   - field_terminator
   - line_terminator
   - escaped_by
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'field_terminator', None, None, ), # 1
    (2, TType.STRING, 'line_terminator', None, None, ), # 2
    (3, TType.STRING, 'escaped_by', None, None, ), # 3
  )

  def __init__(self, field_terminator=None, line_terminator=None, escaped_by=None,):
    self.field_terminator = field_terminator
    self.line_terminator = line_terminator
    self.escaped_by = escaped_by

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.field_terminator = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.line_terminator = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.escaped_by = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TTableRowFormat')
    if self.field_terminator is not None:
      oprot.writeFieldBegin('field_terminator', TType.STRING, 1)
      oprot.writeString(self.field_terminator)
      oprot.writeFieldEnd()
    if self.line_terminator is not None:
      oprot.writeFieldBegin('line_terminator', TType.STRING, 2)
      oprot.writeString(self.line_terminator)
      oprot.writeFieldEnd()
    if self.escaped_by is not None:
      oprot.writeFieldBegin('escaped_by', TType.STRING, 3)
      oprot.writeString(self.escaped_by)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPartitionKeyValue:
  """
  Attributes:
   - name
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'value', None, None, ), # 2
  )

  def __init__(self, name=None, value=None,):
    self.name = name
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPartitionKeyValue')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 2)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.name is None:
      raise TProtocol.TProtocolException(message='Required field name is unset!')
    if self.value is None:
      raise TProtocol.TProtocolException(message='Required field value is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAlterTableRenameParams:
  """
  Attributes:
   - new_table_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'new_table_name', (TTableName, TTableName.thrift_spec), None, ), # 1
  )

  def __init__(self, new_table_name=None,):
    self.new_table_name = new_table_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.new_table_name = TTableName()
          self.new_table_name.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAlterTableRenameParams')
    if self.new_table_name is not None:
      oprot.writeFieldBegin('new_table_name', TType.STRUCT, 1)
      self.new_table_name.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.new_table_name is None:
      raise TProtocol.TProtocolException(message='Required field new_table_name is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAlterTableAddReplaceColsParams:
  """
  Attributes:
   - columns
   - replace_existing_cols
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'columns', (TType.STRUCT,(TColumnDef, TColumnDef.thrift_spec)), None, ), # 1
    (2, TType.BOOL, 'replace_existing_cols', None, None, ), # 2
  )

  def __init__(self, columns=None, replace_existing_cols=None,):
    self.columns = columns
    self.replace_existing_cols = replace_existing_cols

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.columns = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = TColumnDef()
            _elem26.read(iprot)
            self.columns.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.replace_existing_cols = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAlterTableAddReplaceColsParams')
    if self.columns is not None:
      oprot.writeFieldBegin('columns', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.columns))
      for iter27 in self.columns:
        iter27.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.replace_existing_cols is not None:
      oprot.writeFieldBegin('replace_existing_cols', TType.BOOL, 2)
      oprot.writeBool(self.replace_existing_cols)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.columns is None:
      raise TProtocol.TProtocolException(message='Required field columns is unset!')
    if self.replace_existing_cols is None:
      raise TProtocol.TProtocolException(message='Required field replace_existing_cols is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAlterTableAddPartitionParams:
  """
  Attributes:
   - partition_spec
   - if_not_exists
   - location
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'partition_spec', (TType.STRUCT,(TPartitionKeyValue, TPartitionKeyValue.thrift_spec)), None, ), # 1
    (2, TType.STRING, 'location', None, None, ), # 2
    (3, TType.BOOL, 'if_not_exists', None, None, ), # 3
  )

  def __init__(self, partition_spec=None, if_not_exists=None, location=None,):
    self.partition_spec = partition_spec
    self.if_not_exists = if_not_exists
    self.location = location

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.partition_spec = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = TPartitionKeyValue()
            _elem33.read(iprot)
            self.partition_spec.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.location = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAlterTableAddPartitionParams')
    if self.partition_spec is not None:
      oprot.writeFieldBegin('partition_spec', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.partition_spec))
      for iter34 in self.partition_spec:
        iter34.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.location is not None:
      oprot.writeFieldBegin('location', TType.STRING, 2)
      oprot.writeString(self.location)
      oprot.writeFieldEnd()
    if self.if_not_exists is not None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 3)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.partition_spec is None:
      raise TProtocol.TProtocolException(message='Required field partition_spec is unset!')
    if self.if_not_exists is None:
      raise TProtocol.TProtocolException(message='Required field if_not_exists is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAlterTableDropColParams:
  """
  Attributes:
   - col_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'col_name', None, None, ), # 1
  )

  def __init__(self, col_name=None,):
    self.col_name = col_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.col_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAlterTableDropColParams')
    if self.col_name is not None:
      oprot.writeFieldBegin('col_name', TType.STRING, 1)
      oprot.writeString(self.col_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.col_name is None:
      raise TProtocol.TProtocolException(message='Required field col_name is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAlterTableDropPartitionParams:
  """
  Attributes:
   - partition_spec
   - if_exists
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'partition_spec', (TType.STRUCT,(TPartitionKeyValue, TPartitionKeyValue.thrift_spec)), None, ), # 1
    (2, TType.BOOL, 'if_exists', None, None, ), # 2
  )

  def __init__(self, partition_spec=None, if_exists=None,):
    self.partition_spec = partition_spec
    self.if_exists = if_exists

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.partition_spec = []
          (_etype38, _size35) = iprot.readListBegin()
          for _i39 in xrange(_size35):
            _elem40 = TPartitionKeyValue()
            _elem40.read(iprot)
            self.partition_spec.append(_elem40)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.if_exists = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAlterTableDropPartitionParams')
    if self.partition_spec is not None:
      oprot.writeFieldBegin('partition_spec', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.partition_spec))
      for iter41 in self.partition_spec:
        iter41.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.if_exists is not None:
      oprot.writeFieldBegin('if_exists', TType.BOOL, 2)
      oprot.writeBool(self.if_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.partition_spec is None:
      raise TProtocol.TProtocolException(message='Required field partition_spec is unset!')
    if self.if_exists is None:
      raise TProtocol.TProtocolException(message='Required field if_exists is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAlterTableChangeColParams:
  """
  Attributes:
   - col_name
   - new_col_def
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'col_name', None, None, ), # 1
    (2, TType.STRUCT, 'new_col_def', (TColumnDef, TColumnDef.thrift_spec), None, ), # 2
  )

  def __init__(self, col_name=None, new_col_def=None,):
    self.col_name = col_name
    self.new_col_def = new_col_def

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.col_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.new_col_def = TColumnDef()
          self.new_col_def.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAlterTableChangeColParams')
    if self.col_name is not None:
      oprot.writeFieldBegin('col_name', TType.STRING, 1)
      oprot.writeString(self.col_name)
      oprot.writeFieldEnd()
    if self.new_col_def is not None:
      oprot.writeFieldBegin('new_col_def', TType.STRUCT, 2)
      self.new_col_def.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.col_name is None:
      raise TProtocol.TProtocolException(message='Required field col_name is unset!')
    if self.new_col_def is None:
      raise TProtocol.TProtocolException(message='Required field new_col_def is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAlterTableSetFileFormatParams:
  """
  Attributes:
   - file_format
   - partition_spec
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'file_format', None, None, ), # 1
    (2, TType.LIST, 'partition_spec', (TType.STRUCT,(TPartitionKeyValue, TPartitionKeyValue.thrift_spec)), None, ), # 2
  )

  def __init__(self, file_format=None, partition_spec=None,):
    self.file_format = file_format
    self.partition_spec = partition_spec

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.file_format = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.partition_spec = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = TPartitionKeyValue()
            _elem47.read(iprot)
            self.partition_spec.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAlterTableSetFileFormatParams')
    if self.file_format is not None:
      oprot.writeFieldBegin('file_format', TType.I32, 1)
      oprot.writeI32(self.file_format)
      oprot.writeFieldEnd()
    if self.partition_spec is not None:
      oprot.writeFieldBegin('partition_spec', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.partition_spec))
      for iter48 in self.partition_spec:
        iter48.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.file_format is None:
      raise TProtocol.TProtocolException(message='Required field file_format is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAlterTableSetLocationParams:
  """
  Attributes:
   - location
   - partition_spec
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'location', None, None, ), # 1
    (2, TType.LIST, 'partition_spec', (TType.STRUCT,(TPartitionKeyValue, TPartitionKeyValue.thrift_spec)), None, ), # 2
  )

  def __init__(self, location=None, partition_spec=None,):
    self.location = location
    self.partition_spec = partition_spec

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.location = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.partition_spec = []
          (_etype52, _size49) = iprot.readListBegin()
          for _i53 in xrange(_size49):
            _elem54 = TPartitionKeyValue()
            _elem54.read(iprot)
            self.partition_spec.append(_elem54)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAlterTableSetLocationParams')
    if self.location is not None:
      oprot.writeFieldBegin('location', TType.STRING, 1)
      oprot.writeString(self.location)
      oprot.writeFieldEnd()
    if self.partition_spec is not None:
      oprot.writeFieldBegin('partition_spec', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.partition_spec))
      for iter55 in self.partition_spec:
        iter55.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.location is None:
      raise TProtocol.TProtocolException(message='Required field location is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAlterTableParams:
  """
  Attributes:
   - alter_type
   - table_name
   - rename_params
   - add_replace_cols_params
   - add_partition_params
   - change_col_params
   - drop_col_params
   - drop_partition_params
   - set_file_format_params
   - set_location_params
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'alter_type', None, None, ), # 1
    (2, TType.STRUCT, 'table_name', (TTableName, TTableName.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'rename_params', (TAlterTableRenameParams, TAlterTableRenameParams.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'add_replace_cols_params', (TAlterTableAddReplaceColsParams, TAlterTableAddReplaceColsParams.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'add_partition_params', (TAlterTableAddPartitionParams, TAlterTableAddPartitionParams.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'change_col_params', (TAlterTableChangeColParams, TAlterTableChangeColParams.thrift_spec), None, ), # 6
    (7, TType.STRUCT, 'drop_col_params', (TAlterTableDropColParams, TAlterTableDropColParams.thrift_spec), None, ), # 7
    (8, TType.STRUCT, 'drop_partition_params', (TAlterTableDropPartitionParams, TAlterTableDropPartitionParams.thrift_spec), None, ), # 8
    (9, TType.STRUCT, 'set_file_format_params', (TAlterTableSetFileFormatParams, TAlterTableSetFileFormatParams.thrift_spec), None, ), # 9
    (10, TType.STRUCT, 'set_location_params', (TAlterTableSetLocationParams, TAlterTableSetLocationParams.thrift_spec), None, ), # 10
  )

  def __init__(self, alter_type=None, table_name=None, rename_params=None, add_replace_cols_params=None, add_partition_params=None, change_col_params=None, drop_col_params=None, drop_partition_params=None, set_file_format_params=None, set_location_params=None,):
    self.alter_type = alter_type
    self.table_name = table_name
    self.rename_params = rename_params
    self.add_replace_cols_params = add_replace_cols_params
    self.add_partition_params = add_partition_params
    self.change_col_params = change_col_params
    self.drop_col_params = drop_col_params
    self.drop_partition_params = drop_partition_params
    self.set_file_format_params = set_file_format_params
    self.set_location_params = set_location_params

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.alter_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.table_name = TTableName()
          self.table_name.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.rename_params = TAlterTableRenameParams()
          self.rename_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.add_replace_cols_params = TAlterTableAddReplaceColsParams()
          self.add_replace_cols_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.add_partition_params = TAlterTableAddPartitionParams()
          self.add_partition_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.change_col_params = TAlterTableChangeColParams()
          self.change_col_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.drop_col_params = TAlterTableDropColParams()
          self.drop_col_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.drop_partition_params = TAlterTableDropPartitionParams()
          self.drop_partition_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.set_file_format_params = TAlterTableSetFileFormatParams()
          self.set_file_format_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.set_location_params = TAlterTableSetLocationParams()
          self.set_location_params.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAlterTableParams')
    if self.alter_type is not None:
      oprot.writeFieldBegin('alter_type', TType.I32, 1)
      oprot.writeI32(self.alter_type)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRUCT, 2)
      self.table_name.write(oprot)
      oprot.writeFieldEnd()
    if self.rename_params is not None:
      oprot.writeFieldBegin('rename_params', TType.STRUCT, 3)
      self.rename_params.write(oprot)
      oprot.writeFieldEnd()
    if self.add_replace_cols_params is not None:
      oprot.writeFieldBegin('add_replace_cols_params', TType.STRUCT, 4)
      self.add_replace_cols_params.write(oprot)
      oprot.writeFieldEnd()
    if self.add_partition_params is not None:
      oprot.writeFieldBegin('add_partition_params', TType.STRUCT, 5)
      self.add_partition_params.write(oprot)
      oprot.writeFieldEnd()
    if self.change_col_params is not None:
      oprot.writeFieldBegin('change_col_params', TType.STRUCT, 6)
      self.change_col_params.write(oprot)
      oprot.writeFieldEnd()
    if self.drop_col_params is not None:
      oprot.writeFieldBegin('drop_col_params', TType.STRUCT, 7)
      self.drop_col_params.write(oprot)
      oprot.writeFieldEnd()
    if self.drop_partition_params is not None:
      oprot.writeFieldBegin('drop_partition_params', TType.STRUCT, 8)
      self.drop_partition_params.write(oprot)
      oprot.writeFieldEnd()
    if self.set_file_format_params is not None:
      oprot.writeFieldBegin('set_file_format_params', TType.STRUCT, 9)
      self.set_file_format_params.write(oprot)
      oprot.writeFieldEnd()
    if self.set_location_params is not None:
      oprot.writeFieldBegin('set_location_params', TType.STRUCT, 10)
      self.set_location_params.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.alter_type is None:
      raise TProtocol.TProtocolException(message='Required field alter_type is unset!')
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCreateTableLikeParams:
  """
  Attributes:
   - table_name
   - src_table_name
   - is_external
   - if_not_exists
   - location
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'table_name', (TTableName, TTableName.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'src_table_name', (TTableName, TTableName.thrift_spec), None, ), # 2
    (3, TType.BOOL, 'is_external', None, None, ), # 3
    (4, TType.BOOL, 'if_not_exists', None, None, ), # 4
    (5, TType.STRING, 'location', None, None, ), # 5
  )

  def __init__(self, table_name=None, src_table_name=None, is_external=None, if_not_exists=None, location=None,):
    self.table_name = table_name
    self.src_table_name = src_table_name
    self.is_external = is_external
    self.if_not_exists = if_not_exists
    self.location = location

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.table_name = TTableName()
          self.table_name.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.src_table_name = TTableName()
          self.src_table_name.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.is_external = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.location = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCreateTableLikeParams')
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
      self.table_name.write(oprot)
      oprot.writeFieldEnd()
    if self.src_table_name is not None:
      oprot.writeFieldBegin('src_table_name', TType.STRUCT, 2)
      self.src_table_name.write(oprot)
      oprot.writeFieldEnd()
    if self.is_external is not None:
      oprot.writeFieldBegin('is_external', TType.BOOL, 3)
      oprot.writeBool(self.is_external)
      oprot.writeFieldEnd()
    if self.if_not_exists is not None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 4)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    if self.location is not None:
      oprot.writeFieldBegin('location', TType.STRING, 5)
      oprot.writeString(self.location)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    if self.src_table_name is None:
      raise TProtocol.TProtocolException(message='Required field src_table_name is unset!')
    if self.is_external is None:
      raise TProtocol.TProtocolException(message='Required field is_external is unset!')
    if self.if_not_exists is None:
      raise TProtocol.TProtocolException(message='Required field if_not_exists is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCreateTableParams:
  """
  Attributes:
   - table_name
   - columns
   - partition_columns
   - file_format
   - row_format
   - is_external
   - if_not_exists
   - comment
   - location
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'table_name', (TTableName, TTableName.thrift_spec), None, ), # 1
    (2, TType.LIST, 'columns', (TType.STRUCT,(TColumnDef, TColumnDef.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'partition_columns', (TType.STRUCT,(TColumnDef, TColumnDef.thrift_spec)), None, ), # 3
    (4, TType.I32, 'file_format', None, None, ), # 4
    (5, TType.STRUCT, 'row_format', (TTableRowFormat, TTableRowFormat.thrift_spec), None, ), # 5
    (6, TType.BOOL, 'is_external', None, None, ), # 6
    (7, TType.BOOL, 'if_not_exists', None, None, ), # 7
    (8, TType.STRING, 'comment', None, None, ), # 8
    (9, TType.STRING, 'location', None, None, ), # 9
  )

  def __init__(self, table_name=None, columns=None, partition_columns=None, file_format=None, row_format=None, is_external=None, if_not_exists=None, comment=None, location=None,):
    self.table_name = table_name
    self.columns = columns
    self.partition_columns = partition_columns
    self.file_format = file_format
    self.row_format = row_format
    self.is_external = is_external
    self.if_not_exists = if_not_exists
    self.comment = comment
    self.location = location

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.table_name = TTableName()
          self.table_name.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.columns = []
          (_etype59, _size56) = iprot.readListBegin()
          for _i60 in xrange(_size56):
            _elem61 = TColumnDef()
            _elem61.read(iprot)
            self.columns.append(_elem61)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.partition_columns = []
          (_etype65, _size62) = iprot.readListBegin()
          for _i66 in xrange(_size62):
            _elem67 = TColumnDef()
            _elem67.read(iprot)
            self.partition_columns.append(_elem67)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.file_format = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.row_format = TTableRowFormat()
          self.row_format.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.is_external = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.comment = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.location = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCreateTableParams')
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
      self.table_name.write(oprot)
      oprot.writeFieldEnd()
    if self.columns is not None:
      oprot.writeFieldBegin('columns', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.columns))
      for iter68 in self.columns:
        iter68.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.partition_columns is not None:
      oprot.writeFieldBegin('partition_columns', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.partition_columns))
      for iter69 in self.partition_columns:
        iter69.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.file_format is not None:
      oprot.writeFieldBegin('file_format', TType.I32, 4)
      oprot.writeI32(self.file_format)
      oprot.writeFieldEnd()
    if self.row_format is not None:
      oprot.writeFieldBegin('row_format', TType.STRUCT, 5)
      self.row_format.write(oprot)
      oprot.writeFieldEnd()
    if self.is_external is not None:
      oprot.writeFieldBegin('is_external', TType.BOOL, 6)
      oprot.writeBool(self.is_external)
      oprot.writeFieldEnd()
    if self.if_not_exists is not None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 7)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    if self.comment is not None:
      oprot.writeFieldBegin('comment', TType.STRING, 8)
      oprot.writeString(self.comment)
      oprot.writeFieldEnd()
    if self.location is not None:
      oprot.writeFieldBegin('location', TType.STRING, 9)
      oprot.writeString(self.location)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    if self.columns is None:
      raise TProtocol.TProtocolException(message='Required field columns is unset!')
    if self.file_format is None:
      raise TProtocol.TProtocolException(message='Required field file_format is unset!')
    if self.is_external is None:
      raise TProtocol.TProtocolException(message='Required field is_external is unset!')
    if self.if_not_exists is None:
      raise TProtocol.TProtocolException(message='Required field if_not_exists is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDropDbParams:
  """
  Attributes:
   - db
   - if_exists
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db', None, None, ), # 1
    (2, TType.BOOL, 'if_exists', None, None, ), # 2
  )

  def __init__(self, db=None, if_exists=None,):
    self.db = db
    self.if_exists = if_exists

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.if_exists = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDropDbParams')
    if self.db is not None:
      oprot.writeFieldBegin('db', TType.STRING, 1)
      oprot.writeString(self.db)
      oprot.writeFieldEnd()
    if self.if_exists is not None:
      oprot.writeFieldBegin('if_exists', TType.BOOL, 2)
      oprot.writeBool(self.if_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.db is None:
      raise TProtocol.TProtocolException(message='Required field db is unset!')
    if self.if_exists is None:
      raise TProtocol.TProtocolException(message='Required field if_exists is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDropTableParams:
  """
  Attributes:
   - table_name
   - if_exists
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'table_name', (TTableName, TTableName.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'if_exists', None, None, ), # 2
  )

  def __init__(self, table_name=None, if_exists=None,):
    self.table_name = table_name
    self.if_exists = if_exists

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.table_name = TTableName()
          self.table_name.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.if_exists = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDropTableParams')
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
      self.table_name.write(oprot)
      oprot.writeFieldEnd()
    if self.if_exists is not None:
      oprot.writeFieldBegin('if_exists', TType.BOOL, 2)
      oprot.writeBool(self.if_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    if self.if_exists is None:
      raise TProtocol.TProtocolException(message='Required field if_exists is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TSessionState:
  """
  Attributes:
   - database
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'database', None, None, ), # 1
  )

  def __init__(self, database=None,):
    self.database = database

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.database = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TSessionState')
    if self.database is not None:
      oprot.writeFieldBegin('database', TType.STRING, 1)
      oprot.writeString(self.database)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.database is None:
      raise TProtocol.TProtocolException(message='Required field database is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TClientRequest:
  """
  Attributes:
   - stmt
   - queryOptions
   - sessionState
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'stmt', None, None, ), # 1
    (2, TType.STRUCT, 'queryOptions', (ImpalaInternalService.ttypes.TQueryOptions, ImpalaInternalService.ttypes.TQueryOptions.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'sessionState', (TSessionState, TSessionState.thrift_spec), None, ), # 3
  )

  def __init__(self, stmt=None, queryOptions=None, sessionState=None,):
    self.stmt = stmt
    self.queryOptions = queryOptions
    self.sessionState = sessionState

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.stmt = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.queryOptions = ImpalaInternalService.ttypes.TQueryOptions()
          self.queryOptions.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.sessionState = TSessionState()
          self.sessionState.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TClientRequest')
    if self.stmt is not None:
      oprot.writeFieldBegin('stmt', TType.STRING, 1)
      oprot.writeString(self.stmt)
      oprot.writeFieldEnd()
    if self.queryOptions is not None:
      oprot.writeFieldBegin('queryOptions', TType.STRUCT, 2)
      self.queryOptions.write(oprot)
      oprot.writeFieldEnd()
    if self.sessionState is not None:
      oprot.writeFieldBegin('sessionState', TType.STRUCT, 3)
      self.sessionState.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.stmt is None:
      raise TProtocol.TProtocolException(message='Required field stmt is unset!')
    if self.queryOptions is None:
      raise TProtocol.TProtocolException(message='Required field queryOptions is unset!')
    if self.sessionState is None:
      raise TProtocol.TProtocolException(message='Required field sessionState is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TShowDbsParams:
  """
  Attributes:
   - show_pattern
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'show_pattern', None, None, ), # 1
  )

  def __init__(self, show_pattern=None,):
    self.show_pattern = show_pattern

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.show_pattern = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TShowDbsParams')
    if self.show_pattern is not None:
      oprot.writeFieldBegin('show_pattern', TType.STRING, 1)
      oprot.writeString(self.show_pattern)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TShowTablesParams:
  """
  Attributes:
   - db
   - show_pattern
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db', None, None, ), # 1
    (2, TType.STRING, 'show_pattern', None, None, ), # 2
  )

  def __init__(self, db=None, show_pattern=None,):
    self.db = db
    self.show_pattern = show_pattern

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.show_pattern = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TShowTablesParams')
    if self.db is not None:
      oprot.writeFieldBegin('db', TType.STRING, 1)
      oprot.writeString(self.db)
      oprot.writeFieldEnd()
    if self.show_pattern is not None:
      oprot.writeFieldBegin('show_pattern', TType.STRING, 2)
      oprot.writeString(self.show_pattern)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TUseDbParams:
  """
  Attributes:
   - db
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db', None, None, ), # 1
  )

  def __init__(self, db=None,):
    self.db = db

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TUseDbParams')
    if self.db is not None:
      oprot.writeFieldBegin('db', TType.STRING, 1)
      oprot.writeString(self.db)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.db is None:
      raise TProtocol.TProtocolException(message='Required field db is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TResultSetMetadata:
  """
  Attributes:
   - columnDescs
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'columnDescs', (TType.STRUCT,(TColumnDesc, TColumnDesc.thrift_spec)), None, ), # 1
  )

  def __init__(self, columnDescs=None,):
    self.columnDescs = columnDescs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.columnDescs = []
          (_etype73, _size70) = iprot.readListBegin()
          for _i74 in xrange(_size70):
            _elem75 = TColumnDesc()
            _elem75.read(iprot)
            self.columnDescs.append(_elem75)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TResultSetMetadata')
    if self.columnDescs is not None:
      oprot.writeFieldBegin('columnDescs', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.columnDescs))
      for iter76 in self.columnDescs:
        iter76.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.columnDescs is None:
      raise TProtocol.TProtocolException(message='Required field columnDescs is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCatalogUpdate:
  """
  Attributes:
   - target_table
   - db_name
   - created_partitions
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'target_table', None, None, ), # 1
    (2, TType.STRING, 'db_name', None, None, ), # 2
    (3, TType.SET, 'created_partitions', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, target_table=None, db_name=None, created_partitions=None,):
    self.target_table = target_table
    self.db_name = db_name
    self.created_partitions = created_partitions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.target_table = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.SET:
          self.created_partitions = set()
          (_etype80, _size77) = iprot.readSetBegin()
          for _i81 in xrange(_size77):
            _elem82 = iprot.readString();
            self.created_partitions.add(_elem82)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCatalogUpdate')
    if self.target_table is not None:
      oprot.writeFieldBegin('target_table', TType.STRING, 1)
      oprot.writeString(self.target_table)
      oprot.writeFieldEnd()
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 2)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.created_partitions is not None:
      oprot.writeFieldBegin('created_partitions', TType.SET, 3)
      oprot.writeSetBegin(TType.STRING, len(self.created_partitions))
      for iter83 in self.created_partitions:
        oprot.writeString(iter83)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.target_table is None:
      raise TProtocol.TProtocolException(message='Required field target_table is unset!')
    if self.db_name is None:
      raise TProtocol.TProtocolException(message='Required field db_name is unset!')
    if self.created_partitions is None:
      raise TProtocol.TProtocolException(message='Required field created_partitions is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TFinalizeParams:
  """
  Attributes:
   - is_overwrite
   - hdfs_base_dir
   - table_name
   - table_db
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'is_overwrite', None, None, ), # 1
    (2, TType.STRING, 'hdfs_base_dir', None, None, ), # 2
    (3, TType.STRING, 'table_name', None, None, ), # 3
    (4, TType.STRING, 'table_db', None, None, ), # 4
  )

  def __init__(self, is_overwrite=None, hdfs_base_dir=None, table_name=None, table_db=None,):
    self.is_overwrite = is_overwrite
    self.hdfs_base_dir = hdfs_base_dir
    self.table_name = table_name
    self.table_db = table_db

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.is_overwrite = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.hdfs_base_dir = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.table_db = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TFinalizeParams')
    if self.is_overwrite is not None:
      oprot.writeFieldBegin('is_overwrite', TType.BOOL, 1)
      oprot.writeBool(self.is_overwrite)
      oprot.writeFieldEnd()
    if self.hdfs_base_dir is not None:
      oprot.writeFieldBegin('hdfs_base_dir', TType.STRING, 2)
      oprot.writeString(self.hdfs_base_dir)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 3)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.table_db is not None:
      oprot.writeFieldBegin('table_db', TType.STRING, 4)
      oprot.writeString(self.table_db)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.is_overwrite is None:
      raise TProtocol.TProtocolException(message='Required field is_overwrite is unset!')
    if self.hdfs_base_dir is None:
      raise TProtocol.TProtocolException(message='Required field hdfs_base_dir is unset!')
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    if self.table_db is None:
      raise TProtocol.TProtocolException(message='Required field table_db is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TQueryExecRequest:
  """
  Attributes:
   - desc_tbl
   - fragments
   - dest_fragment_idx
   - per_node_scan_ranges
   - result_set_metadata
   - finalize_params
   - query_globals
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'desc_tbl', (Descriptors.ttypes.TDescriptorTable, Descriptors.ttypes.TDescriptorTable.thrift_spec), None, ), # 1
    (2, TType.LIST, 'fragments', (TType.STRUCT,(Planner.ttypes.TPlanFragment, Planner.ttypes.TPlanFragment.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'dest_fragment_idx', (TType.I32,None), None, ), # 3
    (4, TType.MAP, 'per_node_scan_ranges', (TType.I32,None,TType.LIST,(TType.STRUCT,(Planner.ttypes.TScanRangeLocations, Planner.ttypes.TScanRangeLocations.thrift_spec))), None, ), # 4
    (5, TType.STRUCT, 'result_set_metadata', (TResultSetMetadata, TResultSetMetadata.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'finalize_params', (TFinalizeParams, TFinalizeParams.thrift_spec), None, ), # 6
    (7, TType.STRUCT, 'query_globals', (ImpalaInternalService.ttypes.TQueryGlobals, ImpalaInternalService.ttypes.TQueryGlobals.thrift_spec), None, ), # 7
  )

  def __init__(self, desc_tbl=None, fragments=None, dest_fragment_idx=None, per_node_scan_ranges=None, result_set_metadata=None, finalize_params=None, query_globals=None,):
    self.desc_tbl = desc_tbl
    self.fragments = fragments
    self.dest_fragment_idx = dest_fragment_idx
    self.per_node_scan_ranges = per_node_scan_ranges
    self.result_set_metadata = result_set_metadata
    self.finalize_params = finalize_params
    self.query_globals = query_globals

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.desc_tbl = Descriptors.ttypes.TDescriptorTable()
          self.desc_tbl.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.fragments = []
          (_etype87, _size84) = iprot.readListBegin()
          for _i88 in xrange(_size84):
            _elem89 = Planner.ttypes.TPlanFragment()
            _elem89.read(iprot)
            self.fragments.append(_elem89)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.dest_fragment_idx = []
          (_etype93, _size90) = iprot.readListBegin()
          for _i94 in xrange(_size90):
            _elem95 = iprot.readI32();
            self.dest_fragment_idx.append(_elem95)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.per_node_scan_ranges = {}
          (_ktype97, _vtype98, _size96 ) = iprot.readMapBegin() 
          for _i100 in xrange(_size96):
            _key101 = iprot.readI32();
            _val102 = []
            (_etype106, _size103) = iprot.readListBegin()
            for _i107 in xrange(_size103):
              _elem108 = Planner.ttypes.TScanRangeLocations()
              _elem108.read(iprot)
              _val102.append(_elem108)
            iprot.readListEnd()
            self.per_node_scan_ranges[_key101] = _val102
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.result_set_metadata = TResultSetMetadata()
          self.result_set_metadata.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.finalize_params = TFinalizeParams()
          self.finalize_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.query_globals = ImpalaInternalService.ttypes.TQueryGlobals()
          self.query_globals.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TQueryExecRequest')
    if self.desc_tbl is not None:
      oprot.writeFieldBegin('desc_tbl', TType.STRUCT, 1)
      self.desc_tbl.write(oprot)
      oprot.writeFieldEnd()
    if self.fragments is not None:
      oprot.writeFieldBegin('fragments', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.fragments))
      for iter109 in self.fragments:
        iter109.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.dest_fragment_idx is not None:
      oprot.writeFieldBegin('dest_fragment_idx', TType.LIST, 3)
      oprot.writeListBegin(TType.I32, len(self.dest_fragment_idx))
      for iter110 in self.dest_fragment_idx:
        oprot.writeI32(iter110)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.per_node_scan_ranges is not None:
      oprot.writeFieldBegin('per_node_scan_ranges', TType.MAP, 4)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.per_node_scan_ranges))
      for kiter111,viter112 in self.per_node_scan_ranges.items():
        oprot.writeI32(kiter111)
        oprot.writeListBegin(TType.STRUCT, len(viter112))
        for iter113 in viter112:
          iter113.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.result_set_metadata is not None:
      oprot.writeFieldBegin('result_set_metadata', TType.STRUCT, 5)
      self.result_set_metadata.write(oprot)
      oprot.writeFieldEnd()
    if self.finalize_params is not None:
      oprot.writeFieldBegin('finalize_params', TType.STRUCT, 6)
      self.finalize_params.write(oprot)
      oprot.writeFieldEnd()
    if self.query_globals is not None:
      oprot.writeFieldBegin('query_globals', TType.STRUCT, 7)
      self.query_globals.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.fragments is None:
      raise TProtocol.TProtocolException(message='Required field fragments is unset!')
    if self.query_globals is None:
      raise TProtocol.TProtocolException(message='Required field query_globals is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDdlExecRequest:
  """
  Attributes:
   - ddl_type
   - use_db_params
   - describe_table_params
   - show_dbs_params
   - show_tables_params
   - alter_table_params
   - create_db_params
   - create_table_params
   - create_table_like_params
   - drop_db_params
   - drop_table_params
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'ddl_type', None, None, ), # 1
    (2, TType.STRUCT, 'use_db_params', (TUseDbParams, TUseDbParams.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'describe_table_params', (TDescribeTableParams, TDescribeTableParams.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'show_dbs_params', (TShowDbsParams, TShowDbsParams.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'show_tables_params', (TShowTablesParams, TShowTablesParams.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'alter_table_params', (TAlterTableParams, TAlterTableParams.thrift_spec), None, ), # 6
    (7, TType.STRUCT, 'create_db_params', (TCreateDbParams, TCreateDbParams.thrift_spec), None, ), # 7
    (8, TType.STRUCT, 'create_table_params', (TCreateTableParams, TCreateTableParams.thrift_spec), None, ), # 8
    (9, TType.STRUCT, 'create_table_like_params', (TCreateTableLikeParams, TCreateTableLikeParams.thrift_spec), None, ), # 9
    (10, TType.STRUCT, 'drop_db_params', (TDropDbParams, TDropDbParams.thrift_spec), None, ), # 10
    (11, TType.STRUCT, 'drop_table_params', (TDropTableParams, TDropTableParams.thrift_spec), None, ), # 11
  )

  def __init__(self, ddl_type=None, use_db_params=None, describe_table_params=None, show_dbs_params=None, show_tables_params=None, alter_table_params=None, create_db_params=None, create_table_params=None, create_table_like_params=None, drop_db_params=None, drop_table_params=None,):
    self.ddl_type = ddl_type
    self.use_db_params = use_db_params
    self.describe_table_params = describe_table_params
    self.show_dbs_params = show_dbs_params
    self.show_tables_params = show_tables_params
    self.alter_table_params = alter_table_params
    self.create_db_params = create_db_params
    self.create_table_params = create_table_params
    self.create_table_like_params = create_table_like_params
    self.drop_db_params = drop_db_params
    self.drop_table_params = drop_table_params

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.ddl_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.use_db_params = TUseDbParams()
          self.use_db_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.describe_table_params = TDescribeTableParams()
          self.describe_table_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.show_dbs_params = TShowDbsParams()
          self.show_dbs_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.show_tables_params = TShowTablesParams()
          self.show_tables_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.alter_table_params = TAlterTableParams()
          self.alter_table_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.create_db_params = TCreateDbParams()
          self.create_db_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.create_table_params = TCreateTableParams()
          self.create_table_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.create_table_like_params = TCreateTableLikeParams()
          self.create_table_like_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.drop_db_params = TDropDbParams()
          self.drop_db_params.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.drop_table_params = TDropTableParams()
          self.drop_table_params.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDdlExecRequest')
    if self.ddl_type is not None:
      oprot.writeFieldBegin('ddl_type', TType.I32, 1)
      oprot.writeI32(self.ddl_type)
      oprot.writeFieldEnd()
    if self.use_db_params is not None:
      oprot.writeFieldBegin('use_db_params', TType.STRUCT, 2)
      self.use_db_params.write(oprot)
      oprot.writeFieldEnd()
    if self.describe_table_params is not None:
      oprot.writeFieldBegin('describe_table_params', TType.STRUCT, 3)
      self.describe_table_params.write(oprot)
      oprot.writeFieldEnd()
    if self.show_dbs_params is not None:
      oprot.writeFieldBegin('show_dbs_params', TType.STRUCT, 4)
      self.show_dbs_params.write(oprot)
      oprot.writeFieldEnd()
    if self.show_tables_params is not None:
      oprot.writeFieldBegin('show_tables_params', TType.STRUCT, 5)
      self.show_tables_params.write(oprot)
      oprot.writeFieldEnd()
    if self.alter_table_params is not None:
      oprot.writeFieldBegin('alter_table_params', TType.STRUCT, 6)
      self.alter_table_params.write(oprot)
      oprot.writeFieldEnd()
    if self.create_db_params is not None:
      oprot.writeFieldBegin('create_db_params', TType.STRUCT, 7)
      self.create_db_params.write(oprot)
      oprot.writeFieldEnd()
    if self.create_table_params is not None:
      oprot.writeFieldBegin('create_table_params', TType.STRUCT, 8)
      self.create_table_params.write(oprot)
      oprot.writeFieldEnd()
    if self.create_table_like_params is not None:
      oprot.writeFieldBegin('create_table_like_params', TType.STRUCT, 9)
      self.create_table_like_params.write(oprot)
      oprot.writeFieldEnd()
    if self.drop_db_params is not None:
      oprot.writeFieldBegin('drop_db_params', TType.STRUCT, 10)
      self.drop_db_params.write(oprot)
      oprot.writeFieldEnd()
    if self.drop_table_params is not None:
      oprot.writeFieldBegin('drop_table_params', TType.STRUCT, 11)
      self.drop_table_params.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.ddl_type is None:
      raise TProtocol.TProtocolException(message='Required field ddl_type is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TMetadataOpRequest:
  """
  Attributes:
   - opcode
   - get_info_req
   - get_type_info_req
   - get_catalogs_req
   - get_schemas_req
   - get_tables_req
   - get_table_types_req
   - get_columns_req
   - get_functions_req
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'opcode', None, None, ), # 1
    (2, TType.STRUCT, 'get_info_req', (cli_service.ttypes.TGetInfoReq, cli_service.ttypes.TGetInfoReq.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'get_type_info_req', (cli_service.ttypes.TGetTypeInfoReq, cli_service.ttypes.TGetTypeInfoReq.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'get_catalogs_req', (cli_service.ttypes.TGetCatalogsReq, cli_service.ttypes.TGetCatalogsReq.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'get_schemas_req', (cli_service.ttypes.TGetSchemasReq, cli_service.ttypes.TGetSchemasReq.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'get_tables_req', (cli_service.ttypes.TGetTablesReq, cli_service.ttypes.TGetTablesReq.thrift_spec), None, ), # 6
    (7, TType.STRUCT, 'get_table_types_req', (cli_service.ttypes.TGetTableTypesReq, cli_service.ttypes.TGetTableTypesReq.thrift_spec), None, ), # 7
    (8, TType.STRUCT, 'get_columns_req', (cli_service.ttypes.TGetColumnsReq, cli_service.ttypes.TGetColumnsReq.thrift_spec), None, ), # 8
    (9, TType.STRUCT, 'get_functions_req', (cli_service.ttypes.TGetFunctionsReq, cli_service.ttypes.TGetFunctionsReq.thrift_spec), None, ), # 9
  )

  def __init__(self, opcode=None, get_info_req=None, get_type_info_req=None, get_catalogs_req=None, get_schemas_req=None, get_tables_req=None, get_table_types_req=None, get_columns_req=None, get_functions_req=None,):
    self.opcode = opcode
    self.get_info_req = get_info_req
    self.get_type_info_req = get_type_info_req
    self.get_catalogs_req = get_catalogs_req
    self.get_schemas_req = get_schemas_req
    self.get_tables_req = get_tables_req
    self.get_table_types_req = get_table_types_req
    self.get_columns_req = get_columns_req
    self.get_functions_req = get_functions_req

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.opcode = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.get_info_req = cli_service.ttypes.TGetInfoReq()
          self.get_info_req.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.get_type_info_req = cli_service.ttypes.TGetTypeInfoReq()
          self.get_type_info_req.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.get_catalogs_req = cli_service.ttypes.TGetCatalogsReq()
          self.get_catalogs_req.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.get_schemas_req = cli_service.ttypes.TGetSchemasReq()
          self.get_schemas_req.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.get_tables_req = cli_service.ttypes.TGetTablesReq()
          self.get_tables_req.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.get_table_types_req = cli_service.ttypes.TGetTableTypesReq()
          self.get_table_types_req.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.get_columns_req = cli_service.ttypes.TGetColumnsReq()
          self.get_columns_req.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.get_functions_req = cli_service.ttypes.TGetFunctionsReq()
          self.get_functions_req.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TMetadataOpRequest')
    if self.opcode is not None:
      oprot.writeFieldBegin('opcode', TType.I32, 1)
      oprot.writeI32(self.opcode)
      oprot.writeFieldEnd()
    if self.get_info_req is not None:
      oprot.writeFieldBegin('get_info_req', TType.STRUCT, 2)
      self.get_info_req.write(oprot)
      oprot.writeFieldEnd()
    if self.get_type_info_req is not None:
      oprot.writeFieldBegin('get_type_info_req', TType.STRUCT, 3)
      self.get_type_info_req.write(oprot)
      oprot.writeFieldEnd()
    if self.get_catalogs_req is not None:
      oprot.writeFieldBegin('get_catalogs_req', TType.STRUCT, 4)
      self.get_catalogs_req.write(oprot)
      oprot.writeFieldEnd()
    if self.get_schemas_req is not None:
      oprot.writeFieldBegin('get_schemas_req', TType.STRUCT, 5)
      self.get_schemas_req.write(oprot)
      oprot.writeFieldEnd()
    if self.get_tables_req is not None:
      oprot.writeFieldBegin('get_tables_req', TType.STRUCT, 6)
      self.get_tables_req.write(oprot)
      oprot.writeFieldEnd()
    if self.get_table_types_req is not None:
      oprot.writeFieldBegin('get_table_types_req', TType.STRUCT, 7)
      self.get_table_types_req.write(oprot)
      oprot.writeFieldEnd()
    if self.get_columns_req is not None:
      oprot.writeFieldBegin('get_columns_req', TType.STRUCT, 8)
      self.get_columns_req.write(oprot)
      oprot.writeFieldEnd()
    if self.get_functions_req is not None:
      oprot.writeFieldBegin('get_functions_req', TType.STRUCT, 9)
      self.get_functions_req.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.opcode is None:
      raise TProtocol.TProtocolException(message='Required field opcode is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TMetadataOpResponse:
  """
  Attributes:
   - request_id
   - result_set_metadata
   - results
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request_id', (Types.ttypes.TUniqueId, Types.ttypes.TUniqueId.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'result_set_metadata', (TResultSetMetadata, TResultSetMetadata.thrift_spec), None, ), # 2
    (3, TType.LIST, 'results', (TType.STRUCT,(Data.ttypes.TResultRow, Data.ttypes.TResultRow.thrift_spec)), None, ), # 3
  )

  def __init__(self, request_id=None, result_set_metadata=None, results=None,):
    self.request_id = request_id
    self.result_set_metadata = result_set_metadata
    self.results = results

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request_id = Types.ttypes.TUniqueId()
          self.request_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.result_set_metadata = TResultSetMetadata()
          self.result_set_metadata.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.results = []
          (_etype117, _size114) = iprot.readListBegin()
          for _i118 in xrange(_size114):
            _elem119 = Data.ttypes.TResultRow()
            _elem119.read(iprot)
            self.results.append(_elem119)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TMetadataOpResponse')
    if self.request_id is not None:
      oprot.writeFieldBegin('request_id', TType.STRUCT, 1)
      self.request_id.write(oprot)
      oprot.writeFieldEnd()
    if self.result_set_metadata is not None:
      oprot.writeFieldBegin('result_set_metadata', TType.STRUCT, 2)
      self.result_set_metadata.write(oprot)
      oprot.writeFieldEnd()
    if self.results is not None:
      oprot.writeFieldBegin('results', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.results))
      for iter120 in self.results:
        iter120.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.request_id is None:
      raise TProtocol.TProtocolException(message='Required field request_id is unset!')
    if self.result_set_metadata is None:
      raise TProtocol.TProtocolException(message='Required field result_set_metadata is unset!')
    if self.results is None:
      raise TProtocol.TProtocolException(message='Required field results is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TExecRequest:
  """
  Attributes:
   - stmt_type
   - sql_stmt
   - request_id
   - query_options
   - query_exec_request
   - ddl_exec_request
   - result_set_metadata
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'stmt_type', None, None, ), # 1
    (2, TType.STRING, 'sql_stmt', None, None, ), # 2
    (3, TType.STRUCT, 'request_id', (Types.ttypes.TUniqueId, Types.ttypes.TUniqueId.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'query_options', (ImpalaInternalService.ttypes.TQueryOptions, ImpalaInternalService.ttypes.TQueryOptions.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'query_exec_request', (TQueryExecRequest, TQueryExecRequest.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'ddl_exec_request', (TDdlExecRequest, TDdlExecRequest.thrift_spec), None, ), # 6
    (7, TType.STRUCT, 'result_set_metadata', (TResultSetMetadata, TResultSetMetadata.thrift_spec), None, ), # 7
  )

  def __init__(self, stmt_type=None, sql_stmt=None, request_id=None, query_options=None, query_exec_request=None, ddl_exec_request=None, result_set_metadata=None,):
    self.stmt_type = stmt_type
    self.sql_stmt = sql_stmt
    self.request_id = request_id
    self.query_options = query_options
    self.query_exec_request = query_exec_request
    self.ddl_exec_request = ddl_exec_request
    self.result_set_metadata = result_set_metadata

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.stmt_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.sql_stmt = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.request_id = Types.ttypes.TUniqueId()
          self.request_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.query_options = ImpalaInternalService.ttypes.TQueryOptions()
          self.query_options.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.query_exec_request = TQueryExecRequest()
          self.query_exec_request.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.ddl_exec_request = TDdlExecRequest()
          self.ddl_exec_request.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.result_set_metadata = TResultSetMetadata()
          self.result_set_metadata.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TExecRequest')
    if self.stmt_type is not None:
      oprot.writeFieldBegin('stmt_type', TType.I32, 1)
      oprot.writeI32(self.stmt_type)
      oprot.writeFieldEnd()
    if self.sql_stmt is not None:
      oprot.writeFieldBegin('sql_stmt', TType.STRING, 2)
      oprot.writeString(self.sql_stmt)
      oprot.writeFieldEnd()
    if self.request_id is not None:
      oprot.writeFieldBegin('request_id', TType.STRUCT, 3)
      self.request_id.write(oprot)
      oprot.writeFieldEnd()
    if self.query_options is not None:
      oprot.writeFieldBegin('query_options', TType.STRUCT, 4)
      self.query_options.write(oprot)
      oprot.writeFieldEnd()
    if self.query_exec_request is not None:
      oprot.writeFieldBegin('query_exec_request', TType.STRUCT, 5)
      self.query_exec_request.write(oprot)
      oprot.writeFieldEnd()
    if self.ddl_exec_request is not None:
      oprot.writeFieldBegin('ddl_exec_request', TType.STRUCT, 6)
      self.ddl_exec_request.write(oprot)
      oprot.writeFieldEnd()
    if self.result_set_metadata is not None:
      oprot.writeFieldBegin('result_set_metadata', TType.STRUCT, 7)
      self.result_set_metadata.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.stmt_type is None:
      raise TProtocol.TProtocolException(message='Required field stmt_type is unset!')
    if self.request_id is None:
      raise TProtocol.TProtocolException(message='Required field request_id is unset!')
    if self.query_options is None:
      raise TProtocol.TProtocolException(message='Required field query_options is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
