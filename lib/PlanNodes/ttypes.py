#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import Exprs.ttypes
import Types.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class TPlanNodeType:
  HDFS_SCAN_NODE = 0
  HBASE_SCAN_NODE = 1
  HASH_JOIN_NODE = 2
  AGGREGATION_NODE = 3
  SORT_NODE = 4
  EXCHANGE_NODE = 5
  MERGE_NODE = 6
  SELECT_NODE = 7

  _VALUES_TO_NAMES = {
    0: "HDFS_SCAN_NODE",
    1: "HBASE_SCAN_NODE",
    2: "HASH_JOIN_NODE",
    3: "AGGREGATION_NODE",
    4: "SORT_NODE",
    5: "EXCHANGE_NODE",
    6: "MERGE_NODE",
    7: "SELECT_NODE",
  }

  _NAMES_TO_VALUES = {
    "HDFS_SCAN_NODE": 0,
    "HBASE_SCAN_NODE": 1,
    "HASH_JOIN_NODE": 2,
    "AGGREGATION_NODE": 3,
    "SORT_NODE": 4,
    "EXCHANGE_NODE": 5,
    "MERGE_NODE": 6,
    "SELECT_NODE": 7,
  }

class TExecNodePhase:
  PREPARE = 0
  OPEN = 1
  GETNEXT = 2
  CLOSE = 3
  INVALID = 4

  _VALUES_TO_NAMES = {
    0: "PREPARE",
    1: "OPEN",
    2: "GETNEXT",
    3: "CLOSE",
    4: "INVALID",
  }

  _NAMES_TO_VALUES = {
    "PREPARE": 0,
    "OPEN": 1,
    "GETNEXT": 2,
    "CLOSE": 3,
    "INVALID": 4,
  }

class TDebugAction:
  WAIT = 0
  FAIL = 1

  _VALUES_TO_NAMES = {
    0: "WAIT",
    1: "FAIL",
  }

  _NAMES_TO_VALUES = {
    "WAIT": 0,
    "FAIL": 1,
  }

class TJoinOp:
  INNER_JOIN = 0
  LEFT_OUTER_JOIN = 1
  LEFT_SEMI_JOIN = 2
  RIGHT_OUTER_JOIN = 3
  FULL_OUTER_JOIN = 4

  _VALUES_TO_NAMES = {
    0: "INNER_JOIN",
    1: "LEFT_OUTER_JOIN",
    2: "LEFT_SEMI_JOIN",
    3: "RIGHT_OUTER_JOIN",
    4: "FULL_OUTER_JOIN",
  }

  _NAMES_TO_VALUES = {
    "INNER_JOIN": 0,
    "LEFT_OUTER_JOIN": 1,
    "LEFT_SEMI_JOIN": 2,
    "RIGHT_OUTER_JOIN": 3,
    "FULL_OUTER_JOIN": 4,
  }


class THdfsFileSplit:
  """
  Attributes:
   - path
   - offset
   - length
   - partition_id
   - file_length
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
    (2, TType.I64, 'offset', None, None, ), # 2
    (3, TType.I64, 'length', None, None, ), # 3
    (4, TType.I64, 'partition_id', None, None, ), # 4
    (5, TType.I64, 'file_length', None, None, ), # 5
  )

  def __init__(self, path=None, offset=None, length=None, partition_id=None, file_length=None,):
    self.path = path
    self.offset = offset
    self.length = length
    self.partition_id = partition_id
    self.file_length = file_length

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.offset = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.length = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.partition_id = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.file_length = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THdfsFileSplit')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.I64, 2)
      oprot.writeI64(self.offset)
      oprot.writeFieldEnd()
    if self.length is not None:
      oprot.writeFieldBegin('length', TType.I64, 3)
      oprot.writeI64(self.length)
      oprot.writeFieldEnd()
    if self.partition_id is not None:
      oprot.writeFieldBegin('partition_id', TType.I64, 4)
      oprot.writeI64(self.partition_id)
      oprot.writeFieldEnd()
    if self.file_length is not None:
      oprot.writeFieldBegin('file_length', TType.I64, 5)
      oprot.writeI64(self.file_length)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.path is None:
      raise TProtocol.TProtocolException(message='Required field path is unset!')
    if self.offset is None:
      raise TProtocol.TProtocolException(message='Required field offset is unset!')
    if self.length is None:
      raise TProtocol.TProtocolException(message='Required field length is unset!')
    if self.partition_id is None:
      raise TProtocol.TProtocolException(message='Required field partition_id is unset!')
    if self.file_length is None:
      raise TProtocol.TProtocolException(message='Required field file_length is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class THBaseKeyRange:
  """
  Attributes:
   - startKey
   - stopKey
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'startKey', None, None, ), # 1
    (2, TType.STRING, 'stopKey', None, None, ), # 2
  )

  def __init__(self, startKey=None, stopKey=None,):
    self.startKey = startKey
    self.stopKey = stopKey

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.startKey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.stopKey = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THBaseKeyRange')
    if self.startKey is not None:
      oprot.writeFieldBegin('startKey', TType.STRING, 1)
      oprot.writeString(self.startKey)
      oprot.writeFieldEnd()
    if self.stopKey is not None:
      oprot.writeFieldBegin('stopKey', TType.STRING, 2)
      oprot.writeString(self.stopKey)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TScanRange:
  """
  Attributes:
   - hdfs_file_split
   - hbase_key_range
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'hdfs_file_split', (THdfsFileSplit, THdfsFileSplit.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'hbase_key_range', (THBaseKeyRange, THBaseKeyRange.thrift_spec), None, ), # 2
  )

  def __init__(self, hdfs_file_split=None, hbase_key_range=None,):
    self.hdfs_file_split = hdfs_file_split
    self.hbase_key_range = hbase_key_range

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.hdfs_file_split = THdfsFileSplit()
          self.hdfs_file_split.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.hbase_key_range = THBaseKeyRange()
          self.hbase_key_range.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TScanRange')
    if self.hdfs_file_split is not None:
      oprot.writeFieldBegin('hdfs_file_split', TType.STRUCT, 1)
      self.hdfs_file_split.write(oprot)
      oprot.writeFieldEnd()
    if self.hbase_key_range is not None:
      oprot.writeFieldBegin('hbase_key_range', TType.STRUCT, 2)
      self.hbase_key_range.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class THdfsScanNode:
  """
  Attributes:
   - tuple_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'tuple_id', None, None, ), # 1
  )

  def __init__(self, tuple_id=None,):
    self.tuple_id = tuple_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.tuple_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THdfsScanNode')
    if self.tuple_id is not None:
      oprot.writeFieldBegin('tuple_id', TType.I32, 1)
      oprot.writeI32(self.tuple_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tuple_id is None:
      raise TProtocol.TProtocolException(message='Required field tuple_id is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class THBaseFilter:
  """
  Attributes:
   - family
   - qualifier
   - op_ordinal
   - filter_constant
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'family', None, None, ), # 1
    (2, TType.STRING, 'qualifier', None, None, ), # 2
    (3, TType.I32, 'op_ordinal', None, None, ), # 3
    (4, TType.STRING, 'filter_constant', None, None, ), # 4
  )

  def __init__(self, family=None, qualifier=None, op_ordinal=None, filter_constant=None,):
    self.family = family
    self.qualifier = qualifier
    self.op_ordinal = op_ordinal
    self.filter_constant = filter_constant

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.family = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.qualifier = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.op_ordinal = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.filter_constant = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THBaseFilter')
    if self.family is not None:
      oprot.writeFieldBegin('family', TType.STRING, 1)
      oprot.writeString(self.family)
      oprot.writeFieldEnd()
    if self.qualifier is not None:
      oprot.writeFieldBegin('qualifier', TType.STRING, 2)
      oprot.writeString(self.qualifier)
      oprot.writeFieldEnd()
    if self.op_ordinal is not None:
      oprot.writeFieldBegin('op_ordinal', TType.I32, 3)
      oprot.writeI32(self.op_ordinal)
      oprot.writeFieldEnd()
    if self.filter_constant is not None:
      oprot.writeFieldBegin('filter_constant', TType.STRING, 4)
      oprot.writeString(self.filter_constant)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.family is None:
      raise TProtocol.TProtocolException(message='Required field family is unset!')
    if self.qualifier is None:
      raise TProtocol.TProtocolException(message='Required field qualifier is unset!')
    if self.op_ordinal is None:
      raise TProtocol.TProtocolException(message='Required field op_ordinal is unset!')
    if self.filter_constant is None:
      raise TProtocol.TProtocolException(message='Required field filter_constant is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class THBaseScanNode:
  """
  Attributes:
   - tuple_id
   - table_name
   - filters
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'tuple_id', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
    (3, TType.LIST, 'filters', (TType.STRUCT,(THBaseFilter, THBaseFilter.thrift_spec)), None, ), # 3
  )

  def __init__(self, tuple_id=None, table_name=None, filters=None,):
    self.tuple_id = tuple_id
    self.table_name = table_name
    self.filters = filters

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.tuple_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.filters = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = THBaseFilter()
            _elem5.read(iprot)
            self.filters.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THBaseScanNode')
    if self.tuple_id is not None:
      oprot.writeFieldBegin('tuple_id', TType.I32, 1)
      oprot.writeI32(self.tuple_id)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.filters is not None:
      oprot.writeFieldBegin('filters', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.filters))
      for iter6 in self.filters:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.tuple_id is None:
      raise TProtocol.TProtocolException(message='Required field tuple_id is unset!')
    if self.table_name is None:
      raise TProtocol.TProtocolException(message='Required field table_name is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TEqJoinCondition:
  """
  Attributes:
   - left
   - right
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'left', (Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'right', (Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec), None, ), # 2
  )

  def __init__(self, left=None, right=None,):
    self.left = left
    self.right = right

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.left = Exprs.ttypes.TExpr()
          self.left.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.right = Exprs.ttypes.TExpr()
          self.right.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TEqJoinCondition')
    if self.left is not None:
      oprot.writeFieldBegin('left', TType.STRUCT, 1)
      self.left.write(oprot)
      oprot.writeFieldEnd()
    if self.right is not None:
      oprot.writeFieldBegin('right', TType.STRUCT, 2)
      self.right.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.left is None:
      raise TProtocol.TProtocolException(message='Required field left is unset!')
    if self.right is None:
      raise TProtocol.TProtocolException(message='Required field right is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class THashJoinNode:
  """
  Attributes:
   - join_op
   - eq_join_conjuncts
   - other_join_conjuncts
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'join_op', None, None, ), # 1
    (2, TType.LIST, 'eq_join_conjuncts', (TType.STRUCT,(TEqJoinCondition, TEqJoinCondition.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'other_join_conjuncts', (TType.STRUCT,(Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec)), None, ), # 3
  )

  def __init__(self, join_op=None, eq_join_conjuncts=None, other_join_conjuncts=None,):
    self.join_op = join_op
    self.eq_join_conjuncts = eq_join_conjuncts
    self.other_join_conjuncts = other_join_conjuncts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.join_op = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.eq_join_conjuncts = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = TEqJoinCondition()
            _elem12.read(iprot)
            self.eq_join_conjuncts.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.other_join_conjuncts = []
          (_etype16, _size13) = iprot.readListBegin()
          for _i17 in xrange(_size13):
            _elem18 = Exprs.ttypes.TExpr()
            _elem18.read(iprot)
            self.other_join_conjuncts.append(_elem18)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THashJoinNode')
    if self.join_op is not None:
      oprot.writeFieldBegin('join_op', TType.I32, 1)
      oprot.writeI32(self.join_op)
      oprot.writeFieldEnd()
    if self.eq_join_conjuncts is not None:
      oprot.writeFieldBegin('eq_join_conjuncts', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.eq_join_conjuncts))
      for iter19 in self.eq_join_conjuncts:
        iter19.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.other_join_conjuncts is not None:
      oprot.writeFieldBegin('other_join_conjuncts', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.other_join_conjuncts))
      for iter20 in self.other_join_conjuncts:
        iter20.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.join_op is None:
      raise TProtocol.TProtocolException(message='Required field join_op is unset!')
    if self.eq_join_conjuncts is None:
      raise TProtocol.TProtocolException(message='Required field eq_join_conjuncts is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAggregationNode:
  """
  Attributes:
   - grouping_exprs
   - aggregate_exprs
   - agg_tuple_id
   - need_finalize
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'grouping_exprs', (TType.STRUCT,(Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec)), None, ), # 1
    (2, TType.LIST, 'aggregate_exprs', (TType.STRUCT,(Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec)), None, ), # 2
    (3, TType.I32, 'agg_tuple_id', None, None, ), # 3
    (4, TType.BOOL, 'need_finalize', None, None, ), # 4
  )

  def __init__(self, grouping_exprs=None, aggregate_exprs=None, agg_tuple_id=None, need_finalize=None,):
    self.grouping_exprs = grouping_exprs
    self.aggregate_exprs = aggregate_exprs
    self.agg_tuple_id = agg_tuple_id
    self.need_finalize = need_finalize

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.grouping_exprs = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = Exprs.ttypes.TExpr()
            _elem26.read(iprot)
            self.grouping_exprs.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.aggregate_exprs = []
          (_etype30, _size27) = iprot.readListBegin()
          for _i31 in xrange(_size27):
            _elem32 = Exprs.ttypes.TExpr()
            _elem32.read(iprot)
            self.aggregate_exprs.append(_elem32)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.agg_tuple_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.need_finalize = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAggregationNode')
    if self.grouping_exprs is not None:
      oprot.writeFieldBegin('grouping_exprs', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.grouping_exprs))
      for iter33 in self.grouping_exprs:
        iter33.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.aggregate_exprs is not None:
      oprot.writeFieldBegin('aggregate_exprs', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.aggregate_exprs))
      for iter34 in self.aggregate_exprs:
        iter34.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.agg_tuple_id is not None:
      oprot.writeFieldBegin('agg_tuple_id', TType.I32, 3)
      oprot.writeI32(self.agg_tuple_id)
      oprot.writeFieldEnd()
    if self.need_finalize is not None:
      oprot.writeFieldBegin('need_finalize', TType.BOOL, 4)
      oprot.writeBool(self.need_finalize)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.aggregate_exprs is None:
      raise TProtocol.TProtocolException(message='Required field aggregate_exprs is unset!')
    if self.agg_tuple_id is None:
      raise TProtocol.TProtocolException(message='Required field agg_tuple_id is unset!')
    if self.need_finalize is None:
      raise TProtocol.TProtocolException(message='Required field need_finalize is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TSortNode:
  """
  Attributes:
   - ordering_exprs
   - is_asc_order
   - use_top_n
   - is_default_limit
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'ordering_exprs', (TType.STRUCT,(Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec)), None, ), # 1
    (2, TType.LIST, 'is_asc_order', (TType.BOOL,None), None, ), # 2
    (3, TType.BOOL, 'use_top_n', None, None, ), # 3
    (4, TType.BOOL, 'is_default_limit', None, None, ), # 4
  )

  def __init__(self, ordering_exprs=None, is_asc_order=None, use_top_n=None, is_default_limit=None,):
    self.ordering_exprs = ordering_exprs
    self.is_asc_order = is_asc_order
    self.use_top_n = use_top_n
    self.is_default_limit = is_default_limit

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.ordering_exprs = []
          (_etype38, _size35) = iprot.readListBegin()
          for _i39 in xrange(_size35):
            _elem40 = Exprs.ttypes.TExpr()
            _elem40.read(iprot)
            self.ordering_exprs.append(_elem40)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.is_asc_order = []
          (_etype44, _size41) = iprot.readListBegin()
          for _i45 in xrange(_size41):
            _elem46 = iprot.readBool();
            self.is_asc_order.append(_elem46)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.use_top_n = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.is_default_limit = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TSortNode')
    if self.ordering_exprs is not None:
      oprot.writeFieldBegin('ordering_exprs', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.ordering_exprs))
      for iter47 in self.ordering_exprs:
        iter47.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.is_asc_order is not None:
      oprot.writeFieldBegin('is_asc_order', TType.LIST, 2)
      oprot.writeListBegin(TType.BOOL, len(self.is_asc_order))
      for iter48 in self.is_asc_order:
        oprot.writeBool(iter48)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.use_top_n is not None:
      oprot.writeFieldBegin('use_top_n', TType.BOOL, 3)
      oprot.writeBool(self.use_top_n)
      oprot.writeFieldEnd()
    if self.is_default_limit is not None:
      oprot.writeFieldBegin('is_default_limit', TType.BOOL, 4)
      oprot.writeBool(self.is_default_limit)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.ordering_exprs is None:
      raise TProtocol.TProtocolException(message='Required field ordering_exprs is unset!')
    if self.is_asc_order is None:
      raise TProtocol.TProtocolException(message='Required field is_asc_order is unset!')
    if self.use_top_n is None:
      raise TProtocol.TProtocolException(message='Required field use_top_n is unset!')
    if self.is_default_limit is None:
      raise TProtocol.TProtocolException(message='Required field is_default_limit is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TMergeNode:
  """
  Attributes:
   - result_expr_lists
   - const_expr_lists
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'result_expr_lists', (TType.LIST,(TType.STRUCT,(Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec))), None, ), # 1
    (2, TType.LIST, 'const_expr_lists', (TType.LIST,(TType.STRUCT,(Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec))), None, ), # 2
  )

  def __init__(self, result_expr_lists=None, const_expr_lists=None,):
    self.result_expr_lists = result_expr_lists
    self.const_expr_lists = const_expr_lists

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.result_expr_lists = []
          (_etype52, _size49) = iprot.readListBegin()
          for _i53 in xrange(_size49):
            _elem54 = []
            (_etype58, _size55) = iprot.readListBegin()
            for _i59 in xrange(_size55):
              _elem60 = Exprs.ttypes.TExpr()
              _elem60.read(iprot)
              _elem54.append(_elem60)
            iprot.readListEnd()
            self.result_expr_lists.append(_elem54)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.const_expr_lists = []
          (_etype64, _size61) = iprot.readListBegin()
          for _i65 in xrange(_size61):
            _elem66 = []
            (_etype70, _size67) = iprot.readListBegin()
            for _i71 in xrange(_size67):
              _elem72 = Exprs.ttypes.TExpr()
              _elem72.read(iprot)
              _elem66.append(_elem72)
            iprot.readListEnd()
            self.const_expr_lists.append(_elem66)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TMergeNode')
    if self.result_expr_lists is not None:
      oprot.writeFieldBegin('result_expr_lists', TType.LIST, 1)
      oprot.writeListBegin(TType.LIST, len(self.result_expr_lists))
      for iter73 in self.result_expr_lists:
        oprot.writeListBegin(TType.STRUCT, len(iter73))
        for iter74 in iter73:
          iter74.write(oprot)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.const_expr_lists is not None:
      oprot.writeFieldBegin('const_expr_lists', TType.LIST, 2)
      oprot.writeListBegin(TType.LIST, len(self.const_expr_lists))
      for iter75 in self.const_expr_lists:
        oprot.writeListBegin(TType.STRUCT, len(iter75))
        for iter76 in iter75:
          iter76.write(oprot)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.result_expr_lists is None:
      raise TProtocol.TProtocolException(message='Required field result_expr_lists is unset!')
    if self.const_expr_lists is None:
      raise TProtocol.TProtocolException(message='Required field const_expr_lists is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPlanNode:
  """
  Attributes:
   - node_id
   - node_type
   - num_children
   - limit
   - row_tuples
   - nullable_tuples
   - conjuncts
   - compact_data
   - hdfs_scan_node
   - hbase_scan_node
   - hash_join_node
   - agg_node
   - sort_node
   - merge_node
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'node_id', None, None, ), # 1
    (2, TType.I32, 'node_type', None, None, ), # 2
    (3, TType.I32, 'num_children', None, None, ), # 3
    (4, TType.I64, 'limit', None, None, ), # 4
    (5, TType.LIST, 'row_tuples', (TType.I32,None), None, ), # 5
    (6, TType.LIST, 'nullable_tuples', (TType.BOOL,None), None, ), # 6
    (7, TType.LIST, 'conjuncts', (TType.STRUCT,(Exprs.ttypes.TExpr, Exprs.ttypes.TExpr.thrift_spec)), None, ), # 7
    (8, TType.BOOL, 'compact_data', None, None, ), # 8
    (9, TType.STRUCT, 'hdfs_scan_node', (THdfsScanNode, THdfsScanNode.thrift_spec), None, ), # 9
    (10, TType.STRUCT, 'hbase_scan_node', (THBaseScanNode, THBaseScanNode.thrift_spec), None, ), # 10
    (11, TType.STRUCT, 'hash_join_node', (THashJoinNode, THashJoinNode.thrift_spec), None, ), # 11
    (12, TType.STRUCT, 'agg_node', (TAggregationNode, TAggregationNode.thrift_spec), None, ), # 12
    (13, TType.STRUCT, 'sort_node', (TSortNode, TSortNode.thrift_spec), None, ), # 13
    (14, TType.STRUCT, 'merge_node', (TMergeNode, TMergeNode.thrift_spec), None, ), # 14
  )

  def __init__(self, node_id=None, node_type=None, num_children=None, limit=None, row_tuples=None, nullable_tuples=None, conjuncts=None, compact_data=None, hdfs_scan_node=None, hbase_scan_node=None, hash_join_node=None, agg_node=None, sort_node=None, merge_node=None,):
    self.node_id = node_id
    self.node_type = node_type
    self.num_children = num_children
    self.limit = limit
    self.row_tuples = row_tuples
    self.nullable_tuples = nullable_tuples
    self.conjuncts = conjuncts
    self.compact_data = compact_data
    self.hdfs_scan_node = hdfs_scan_node
    self.hbase_scan_node = hbase_scan_node
    self.hash_join_node = hash_join_node
    self.agg_node = agg_node
    self.sort_node = sort_node
    self.merge_node = merge_node

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.node_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.node_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.num_children = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.limit = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.row_tuples = []
          (_etype80, _size77) = iprot.readListBegin()
          for _i81 in xrange(_size77):
            _elem82 = iprot.readI32();
            self.row_tuples.append(_elem82)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.nullable_tuples = []
          (_etype86, _size83) = iprot.readListBegin()
          for _i87 in xrange(_size83):
            _elem88 = iprot.readBool();
            self.nullable_tuples.append(_elem88)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.conjuncts = []
          (_etype92, _size89) = iprot.readListBegin()
          for _i93 in xrange(_size89):
            _elem94 = Exprs.ttypes.TExpr()
            _elem94.read(iprot)
            self.conjuncts.append(_elem94)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.compact_data = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.hdfs_scan_node = THdfsScanNode()
          self.hdfs_scan_node.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.hbase_scan_node = THBaseScanNode()
          self.hbase_scan_node.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.hash_join_node = THashJoinNode()
          self.hash_join_node.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRUCT:
          self.agg_node = TAggregationNode()
          self.agg_node.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRUCT:
          self.sort_node = TSortNode()
          self.sort_node.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRUCT:
          self.merge_node = TMergeNode()
          self.merge_node.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPlanNode')
    if self.node_id is not None:
      oprot.writeFieldBegin('node_id', TType.I32, 1)
      oprot.writeI32(self.node_id)
      oprot.writeFieldEnd()
    if self.node_type is not None:
      oprot.writeFieldBegin('node_type', TType.I32, 2)
      oprot.writeI32(self.node_type)
      oprot.writeFieldEnd()
    if self.num_children is not None:
      oprot.writeFieldBegin('num_children', TType.I32, 3)
      oprot.writeI32(self.num_children)
      oprot.writeFieldEnd()
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.I64, 4)
      oprot.writeI64(self.limit)
      oprot.writeFieldEnd()
    if self.row_tuples is not None:
      oprot.writeFieldBegin('row_tuples', TType.LIST, 5)
      oprot.writeListBegin(TType.I32, len(self.row_tuples))
      for iter95 in self.row_tuples:
        oprot.writeI32(iter95)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.nullable_tuples is not None:
      oprot.writeFieldBegin('nullable_tuples', TType.LIST, 6)
      oprot.writeListBegin(TType.BOOL, len(self.nullable_tuples))
      for iter96 in self.nullable_tuples:
        oprot.writeBool(iter96)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.conjuncts is not None:
      oprot.writeFieldBegin('conjuncts', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.conjuncts))
      for iter97 in self.conjuncts:
        iter97.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.compact_data is not None:
      oprot.writeFieldBegin('compact_data', TType.BOOL, 8)
      oprot.writeBool(self.compact_data)
      oprot.writeFieldEnd()
    if self.hdfs_scan_node is not None:
      oprot.writeFieldBegin('hdfs_scan_node', TType.STRUCT, 9)
      self.hdfs_scan_node.write(oprot)
      oprot.writeFieldEnd()
    if self.hbase_scan_node is not None:
      oprot.writeFieldBegin('hbase_scan_node', TType.STRUCT, 10)
      self.hbase_scan_node.write(oprot)
      oprot.writeFieldEnd()
    if self.hash_join_node is not None:
      oprot.writeFieldBegin('hash_join_node', TType.STRUCT, 11)
      self.hash_join_node.write(oprot)
      oprot.writeFieldEnd()
    if self.agg_node is not None:
      oprot.writeFieldBegin('agg_node', TType.STRUCT, 12)
      self.agg_node.write(oprot)
      oprot.writeFieldEnd()
    if self.sort_node is not None:
      oprot.writeFieldBegin('sort_node', TType.STRUCT, 13)
      self.sort_node.write(oprot)
      oprot.writeFieldEnd()
    if self.merge_node is not None:
      oprot.writeFieldBegin('merge_node', TType.STRUCT, 14)
      self.merge_node.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.node_id is None:
      raise TProtocol.TProtocolException(message='Required field node_id is unset!')
    if self.node_type is None:
      raise TProtocol.TProtocolException(message='Required field node_type is unset!')
    if self.num_children is None:
      raise TProtocol.TProtocolException(message='Required field num_children is unset!')
    if self.limit is None:
      raise TProtocol.TProtocolException(message='Required field limit is unset!')
    if self.row_tuples is None:
      raise TProtocol.TProtocolException(message='Required field row_tuples is unset!')
    if self.nullable_tuples is None:
      raise TProtocol.TProtocolException(message='Required field nullable_tuples is unset!')
    if self.compact_data is None:
      raise TProtocol.TProtocolException(message='Required field compact_data is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPlan:
  """
  Attributes:
   - nodes
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'nodes', (TType.STRUCT,(TPlanNode, TPlanNode.thrift_spec)), None, ), # 1
  )

  def __init__(self, nodes=None,):
    self.nodes = nodes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.nodes = []
          (_etype101, _size98) = iprot.readListBegin()
          for _i102 in xrange(_size98):
            _elem103 = TPlanNode()
            _elem103.read(iprot)
            self.nodes.append(_elem103)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPlan')
    if self.nodes is not None:
      oprot.writeFieldBegin('nodes', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.nodes))
      for iter104 in self.nodes:
        iter104.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.nodes is None:
      raise TProtocol.TProtocolException(message='Required field nodes is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
